

===== SOURCE URL =====
https://fastapi.tiangolo.com/
===== PAGE CONTENT =====
FastAPI Skip to content FastAPI ¬∂ FastAPI framework, high performance, easy to learn, fast to code, ready for production Documentation :  https://fastapi.tiangolo.com Source Code :  https://github.com/fastapi/fastapi FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. The key features are: Fast : Very high performance, on par with  NodeJS  and  Go  (thanks to Starlette and Pydantic).  One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300%. * Fewer bugs : Reduce about 40% of human (developer) induced errors. * Intuitive : Great editor support.  Completion  everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs:  OpenAPI  (previously known as Swagger) and  JSON Schema . * estimation based on tests conducted by an internal development team, building production applications. Sponsors ¬∂ Keystone Sponsor ¬∂ Gold and Silver Sponsors ¬∂ Other sponsors Opinions ¬∂ " [...] I'm using  FastAPI  a ton these days. [...] I'm actually planning to use it for all of my team's  ML services at Microsoft . Some of them are getting integrated into the core  Windows  product and some  Office  products. " Kabir Khan -  Microsoft   (ref) " We adopted the  FastAPI  library to spawn a  REST  server that can be queried to obtain  predictions . [for Ludwig] " Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -  Uber   (ref) " Netflix  is pleased to announce the open-source release of our  crisis management  orchestration framework:  Dispatch ! [built with  FastAPI ] " Kevin Glisson, Marc Vilanova, Forest Monsen -  Netflix   (ref) " I‚Äôm over the moon excited about  FastAPI . It‚Äôs so fun! " Brian Okken -  Python Bytes  podcast host   (ref) " Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted  Hug  to be - it's really inspiring to see someone build that. " Timothy Crosley -  Hug  creator   (ref) " If you're looking to learn one  modern framework  for building REST APIs, check out  FastAPI  [...] It's fast, easy to use and easy to learn [...] " " We've switched over to  FastAPI  for our  APIs  [...] I think you'll like it [...] " Ines Montani - Matthew Honnibal -  Explosion AI  founders -  spaCy  creators   (ref)  -  (ref) " If anyone is looking to build a production Python API, I would highly recommend  FastAPI . It is  beautifully designed ,  simple to use  and  highly scalable , it has become a  key component  in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer. " Deon Pillsbury -  Cisco   (ref) FastAPI mini documentary ¬∂ There's a  FastAPI mini documentary  released at the end of 2025, you can watch it online: Typer , the FastAPI of CLIs ¬∂ If you are building a  CLI  app to be used in the terminal instead of a web API, check out  Typer . Typer  is FastAPI's little sibling. And it's intended to be the  FastAPI of CLIs . ‚å®Ô∏è üöÄ Requirements ¬∂ FastAPI stands on the shoulders of giants: Starlette  for the web parts. Pydantic  for the data parts. Installation ¬∂ Create and activate a  virtual environment  and then install FastAPI: $  pip   install   "fastapi[standard]" ---> 100% Note : Make sure you put  "fastapi[standard]"  in quotes to ensure it works in all terminals. Example ¬∂ Create it ¬∂ Create a file  main.py  with: from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) def   read_root (): return   { "Hello" :   "World" } @app . get ( "/items/ {item_id} " ) def   read_item ( item_id :   int ,   q :   Union [ str ,   None ]   =   None ): return   { "item_id" :   item_id ,   "q" :   q } Or use  async def ... If your code uses  async  /  await , use  async def : from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   read_root (): return   { "Hello" :   "World" } @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id :   int ,   q :   Union [ str ,   None ]   =   None ): return   { "item_id" :   item_id ,   "q" :   q } Note : If you don't know, check the  "In a hurry?"  section about  async  and  await  in the docs . Run it ¬∂ Run the server with: $  fastapi   dev   main.py ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ ‚îÇ                                                     ‚îÇ ‚îÇ  Serving at: http://127.0.0.1:8000                  ‚îÇ ‚îÇ                                                     ‚îÇ ‚îÇ  API docs: http://127.0.0.1:8000/docs               ‚îÇ ‚îÇ                                                     ‚îÇ ‚îÇ  Running in development mode, for production use:   ‚îÇ ‚îÇ                                                     ‚îÇ ‚îÇ  fastapi run                                        ‚îÇ ‚îÇ                                                     ‚îÇ ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp'] INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO:     Started reloader process [2248755] using WatchFiles INFO:     Started server process [2248757] INFO:     Waiting for application startup. INFO:     Application startup complete. About the command  fastapi dev main.py ... The command  fastapi dev  reads your  main.py  file, detects the  FastAPI  app in it, and starts a server using  Uvicorn . By default,  fastapi dev  will start with auto-reload enabled for local development. You can read more about it in the  FastAPI CLI docs . Check it ¬∂ Open your browser at  http://127.0.0.1:8000/items/5?q=somequery . You will see the JSON response as: { "item_id" :   5 ,   "q" :   "somequery" } You already created an API that: Receives HTTP requests in the  paths   /  and  /items/{item_id} . Both  paths  take  GET   operations  (also known as HTTP  methods ). The  path   /items/{item_id}  has a  path parameter   item_id  that should be an  int . The  path   /items/{item_id}  has an optional  str   query parameter   q . Interactive API docs ¬∂ Now go to  http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by  Swagger UI ): Alternative API docs ¬∂ And now, go to  http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by  ReDoc ): Example upgrade ¬∂ Now modify the file  main.py  to receive a body from a  PUT  request. Declare the body using standard Python types, thanks to Pydantic. from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel app   =   FastAPI () class   Item ( BaseModel ): name :   str price :   float is_offer :   Union [ bool ,   None ]   =   None @app . get ( "/" ) def   read_root (): return   { "Hello" :   "World" } @app . get ( "/items/ {item_id} " ) def   read_item ( item_id :   int ,   q :   Union [ str ,   None ]   =   None ): return   { "item_id" :   item_id ,   "q" :   q } @app . put ( "/items/ {item_id} " ) def   update_item ( item_id :   int ,   item :   Item ): return   { "item_name" :   item . name ,   "item_id" :   item_id } The  fastapi dev  server should reload automatically. Interactive API docs upgrade ¬∂ Now go to  http://127.0.0.1:8000/docs . The interactive API documentation will be automatically updated, including the new body: Click on the button "Try it out", it allows you to fill the parameters and directly interact with the API: Then click on the "Execute" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen: Alternative API docs upgrade ¬∂ And now, go to  http://127.0.0.1:8000/redoc . The alternative documentation will also reflect the new query parameter and body: Recap ¬∂ In summary, you declare  once  the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard  Python . For example, for an  int : item_id :   int or for a more complex  Item  model: item :   Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion  of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion  of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str ,  int ,  float ,  bool ,  list , etc). datetime  objects. UUID  objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example,  FastAPI  will: Validate that there is an  item_id  in the path for  GET  and  PUT  requests. Validate that the  item_id  is of type  int  for  GET  and  PUT  requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named  q  (as in  http://127.0.0.1:8000/items/foo?q=somequery ) for  GET  requests. As the  q  parameter is declared with  = None , it is optional. Without the  None  it would be required (as is the body in the case with  PUT ). For  PUT  requests to  /items/{item_id} , read the body as JSON: Check that it has a required attribute  name  that should be a  str . Check that it has a required attribute  price  that has to be a  float . Check that it has an optional attribute  is_offer , that should be a  bool , if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems. Automatic client code generation systems, for many languages. Provide 2 interactive documentation web interfaces directly. We just scratched the surface, but you already get the idea of how it all works. Try changing the line with: return   { "item_name" :   item . name ,   "item_id" :   item_id } ...from: ...   "item_name" :   item . name   ... ...to: ...   "item_price" :   item . price   ... ...and see how your editor will auto-complete the attributes and know their types: For a more complete example including more features, see the  Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of  parameters  from other different places as:  headers ,  cookies ,  form fields  and  files . How to set  validation constraints  as  maximum_length  or  regex . A very powerful and easy to use  Dependency Injection  system. Security and authentication, including support for  OAuth2  with  JWT tokens  and  HTTP Basic  auth. More advanced (but equally easy) techniques for declaring  deeply nested JSON models  (thanks to Pydantic). GraphQL  integration with  Strawberry  and other libraries. Many extra features (thanks to Starlette) as: WebSockets extremely easy tests based on HTTPX and  pytest CORS Cookie Sessions ...and more. Deploy your app (optional) ¬∂ You can optionally deploy your FastAPI app to  FastAPI Cloud , go and join the waiting list if you haven't. üöÄ If you already have a  FastAPI Cloud  account (we invited you from the waiting list üòâ), you can deploy your application with one command. Before deploying, make sure you are logged in: $  fastapi   login You are logged in to FastAPI Cloud üöÄ Then deploy your app: $  fastapi   deploy Deploying to FastAPI Cloud... ‚úÖ Deployment successful! üêî Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev That's it! Now you can access your app at that URL. ‚ú® About FastAPI Cloud ¬∂ FastAPI Cloud  is built by the same author and team behind  FastAPI . It streamlines the process of  building ,  deploying , and  accessing  an API with minimal effort. It brings the same  developer experience  of building apps with FastAPI to  deploying  them to the cloud. üéâ FastAPI Cloud is the primary sponsor and funding provider for the  FastAPI and friends  open source projects. ‚ú® Deploy to other cloud providers ¬∂ FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose. Follow your cloud provider's guides to deploy FastAPI apps with them. ü§ì Performance ¬∂ Independent TechEmpower benchmarks show  FastAPI  applications running under Uvicorn as  one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) To understand more about it, see the section  Benchmarks . Dependencies ¬∂ FastAPI depends on Pydantic and Starlette. standard  Dependencies ¬∂ When you install FastAPI with  pip install "fastapi[standard]"  it comes with the  standard  group of optional dependencies: Used by Pydantic: email-validator  - for email validation. Used by Starlette: httpx  - Required if you want to use the  TestClient . jinja2  - Required if you want to use the default template configuration. python-multipart  - Required if you want to support form  "parsing" , with  request.form() . Used by FastAPI: uvicorn  - for the server that loads and serves your application. This includes  uvicorn[standard] , which includes some dependencies (e.g.  uvloop ) needed for high performance serving. fastapi-cli[standard]  - to provide the  fastapi  command. This includes  fastapi-cloud-cli , which allows you to deploy your FastAPI application to  FastAPI Cloud . Without  standard  Dependencies ¬∂ If you don't want to include the  standard  optional dependencies, you can install with  pip install fastapi  instead of  pip install "fastapi[standard]" . Without  fastapi-cloud-cli ¬∂ If you want to install FastAPI with the standard dependencies but without the  fastapi-cloud-cli , you can install with  pip install "fastapi[standard-no-fastapi-cloud-cli]" . Additional Optional Dependencies ¬∂ There are some additional dependencies you might want to install. Additional optional Pydantic dependencies: pydantic-settings  - for settings management. pydantic-extra-types  - for extra types to be used with Pydantic. Additional optional FastAPI dependencies: orjson  - Required if you want to use  ORJSONResponse . ujson  - Required if you want to use  UJSONResponse . License ¬∂ This project is licensed under the terms of the MIT license. Back to top



===== SOURCE URL =====
https://fastapi.tiangolo.com/tutorial/first-steps/
===== PAGE CONTENT =====
First Steps - FastAPI Skip to content First Steps ¬∂ The simplest FastAPI file could look like this: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   root (): return   { "message" :   "Hello World" } Copy that to a file  main.py . Run the live server: $  <font   color = "#4E9A06" >fastapi</font>   dev   <u   style = "text-decoration-style:solid" >main.py</u> <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting development server üöÄ Searching for package file structure from directories with <font color="#3465A4">__init__.py</font> files Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font> <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  üêç main.py <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with the following code: <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u> <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font> <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font> <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000/docs</u></font> <span style="background-color:#007166"><font color="#D3D7CF"> tip </font></span>  Running in development mode, for production use: <b>fastapi run</b> Logs: <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Will watch for changes in these directories: <b>[</b><font color="#4E9A06">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b> <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C to quit<b>)</b> <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started reloader process <b>[</b><font color="#34E2E2"><b>383138</b></font><b>]</b> using WatchFiles <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>383153</b></font><b>]</b> <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup. <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete. In the output, there's a line with something like: INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) That line shows the URL where your app is being served, in your local machine. Check it ¬∂ Open your browser at  http://127.0.0.1:8000 . You will see the JSON response as: { "message" :   "Hello World" } Interactive API docs ¬∂ Now go to  http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by  Swagger UI ): Alternative API docs ¬∂ And now, go to  http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by  ReDoc ): OpenAPI ¬∂ FastAPI  generates a "schema" with all your API using the  OpenAPI  standard for defining APIs. "Schema" ¬∂ A "schema" is a definition or description of something. Not the code that implements it, but just an abstract description. API "schema" ¬∂ In this case,  OpenAPI  is a specification that dictates how to define a schema of your API. This schema definition includes your API paths, the possible parameters they take, etc. Data "schema" ¬∂ The term "schema" might also refer to the shape of some data, like a JSON content. In that case, it would mean the JSON attributes, and data types they have, etc. OpenAPI and JSON Schema ¬∂ OpenAPI defines an API schema for your API. And that schema includes definitions (or "schemas") of the data sent and received by your API using  JSON Schema , the standard for JSON data schemas. Check the  openapi.json ¬∂ If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API. You can see it directly at:  http://127.0.0.1:8000/openapi.json . It will show a JSON starting with something like: { "openapi" :   "3.1.0" , "info" :   { "title" :   "FastAPI" , "version" :   "0.1.0" }, "paths" :   { "/items/" :   { "get" :   { "responses" :   { "200" :   { "description" :   "Successful Response" , "content" :   { "application/json" :   { ... What is OpenAPI for ¬∂ The OpenAPI schema is what powers the two interactive documentation systems included. And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with  FastAPI . You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications. Deploy your app (optional) ¬∂ You can optionally deploy your FastAPI app to  FastAPI Cloud , go and join the waiting list if you haven't. üöÄ If you already have a  FastAPI Cloud  account (we invited you from the waiting list üòâ), you can deploy your application with one command. Before deploying, make sure you are logged in: $  fastapi   login You are logged in to FastAPI Cloud üöÄ Then deploy your app: $  fastapi   deploy Deploying to FastAPI Cloud... ‚úÖ Deployment successful! üêî Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev That's it! Now you can access your app at that URL. ‚ú® Recap, step by step ¬∂ Step 1: import  FastAPI ¬∂ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   root (): return   { "message" :   "Hello World" } FastAPI  is a Python class that provides all the functionality for your API. Technical Details FastAPI  is a class that inherits directly from  Starlette . You can use all the  Starlette  functionality with  FastAPI  too. Step 2: create a  FastAPI  "instance" ¬∂ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   root (): return   { "message" :   "Hello World" } Here the  app  variable will be an "instance" of the class  FastAPI . This will be the main point of interaction to create all your API. Step 3: create a  path operation ¬∂ Path ¬∂ "Path" here refers to the last part of the URL starting from the first  / . So, in a URL like: https://example.com/items/foo ...the path would be: /items/foo Info A "path" is also commonly called an "endpoint" or a "route". While building an API, the "path" is the main way to separate "concerns" and "resources". Operation ¬∂ "Operation" here refers to one of the HTTP "methods". One of: POST GET PUT DELETE ...and the more exotic ones: OPTIONS HEAD PATCH TRACE In the HTTP protocol, you can communicate to each path using one (or more) of these "methods". When building APIs, you normally use these specific HTTP methods to perform a specific action. Normally you use: POST : to create data. GET : to read data. PUT : to update data. DELETE : to delete data. So, in OpenAPI, each of the HTTP methods is called an "operation". We are going to call them " operations " too. Define a  path operation decorator ¬∂ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   root (): return   { "message" :   "Hello World" } The  @app.get("/")  tells  FastAPI  that the function right below is in charge of handling requests that go to: the path  / using a  get  operation @decorator  Info That  @something  syntax in Python is called a "decorator". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A "decorator" takes the function below and does something with it. In our case, this decorator tells  FastAPI  that the function below corresponds to the  path   /  with an  operation   get . It is the " path operation decorator ". You can also use the other operations: @app.post() @app.put() @app.delete() And the more exotic ones: @app.options() @app.head() @app.patch() @app.trace() Tip You are free to use each operation (HTTP method) as you wish. FastAPI  doesn't enforce any specific meaning. The information here is presented as a guideline, not a requirement. For example, when using GraphQL you normally perform all the actions using only  POST  operations. Step 4: define the  path operation function ¬∂ This is our " path operation function ": path : is  / . operation : is  get . function : is the function below the "decorator" (below  @app.get("/") ). Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   root (): return   { "message" :   "Hello World" } This is a Python function. It will be called by  FastAPI  whenever it receives a request to the URL " / " using a  GET  operation. In this case, it is an  async  function. You could also define it as a normal function instead of  async def : Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) def   root (): return   { "message" :   "Hello World" } Note If you don't know the difference, check the  Async:  "In a hurry?" . Step 5: return the content ¬∂ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/" ) async   def   root (): return   { "message" :   "Hello World" } You can return a  dict ,  list , singular values as  str ,  int , etc. You can also return Pydantic models (you'll see more about that later). There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported. Step 6: Deploy it ¬∂ Deploy your app to  FastAPI Cloud  with one command:  fastapi deploy . üéâ About FastAPI Cloud ¬∂ FastAPI Cloud  is built by the same author and team behind  FastAPI . It streamlines the process of  building ,  deploying , and  accessing  an API with minimal effort. It brings the same  developer experience  of building apps with FastAPI to  deploying  them to the cloud. üéâ FastAPI Cloud is the primary sponsor and funding provider for the  FastAPI and friends  open source projects. ‚ú® Deploy to other cloud providers ¬∂ FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose. Follow your cloud provider's guides to deploy FastAPI apps with them. ü§ì Recap ¬∂ Import  FastAPI . Create an  app  instance. Write a  path operation decorator  using decorators like  @app.get("/") . Define a  path operation function ; for example,  def root(): ... . Run the development server using the command  fastapi dev . Optionally deploy your app with  fastapi deploy . Back to top



===== SOURCE URL =====
https://fastapi.tiangolo.com/tutorial/path-params/
===== PAGE CONTENT =====
Path Parameters - FastAPI Skip to content Path Parameters ¬∂ You can declare path "parameters" or "variables" with the same syntax used by Python format strings: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id ): return   { "item_id" :   item_id } The value of the path parameter  item_id  will be passed to your function as the argument  item_id . So, if you run this example and go to  http://127.0.0.1:8000/items/foo , you will see a response of: { "item_id" : "foo" } Path parameters with types ¬∂ You can declare the type of a path parameter in the function, using standard Python type annotations: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id :   int ): return   { "item_id" :   item_id } In this case,  item_id  is declared to be an  int . Check This will give you editor support inside of your function, with error checks, completion, etc. Data  conversion ¬∂ If you run this example and open your browser at  http://127.0.0.1:8000/items/3 , you will see a response of: { "item_id" : 3 } Check Notice that the value your function received (and returned) is  3 , as a Python  int , not a string  "3" . So, with that type declaration,  FastAPI  gives you automatic request  "parsing" . Data validation ¬∂ But if you go to the browser at  http://127.0.0.1:8000/items/foo , you will see a nice HTTP error of: { "detail" :   [ { "type" :   "int_parsing" , "loc" :   [ "path" , "item_id" ], "msg" :   "Input should be a valid integer, unable to parse string as an integer" , "input" :   "foo" } ] } because the path parameter  item_id  had a value of  "foo" , which is not an  int . The same error would appear if you provided a  float  instead of an  int , as in:  http://127.0.0.1:8000/items/4.2 Check So, with the same Python type declaration,  FastAPI  gives you data validation. Notice that the error also clearly states exactly the point where the validation didn't pass. This is incredibly helpful while developing and debugging code that interacts with your API. Documentation ¬∂ And when you open your browser at  http://127.0.0.1:8000/docs , you will see an automatic, interactive, API documentation like: Check Again, just with that same Python type declaration,  FastAPI  gives you automatic, interactive documentation (integrating Swagger UI). Notice that the path parameter is declared to be an integer. Standards-based benefits, alternative documentation ¬∂ And because the generated schema is from the  OpenAPI  standard, there are many compatible tools. Because of this,  FastAPI  itself provides an alternative API documentation (using ReDoc), which you can access at  http://127.0.0.1:8000/redoc : The same way, there are many compatible tools. Including code generation tools for many languages. Pydantic ¬∂ All the data validation is performed under the hood by  Pydantic , so you get all the benefits from it. And you know you are in good hands. You can use the same type declarations with  str ,  float ,  bool  and many other complex data types. Several of these are explored in the next chapters of the tutorial. Order matters ¬∂ When creating  path operations , you can find situations where you have a fixed path. Like  /users/me , let's say that it's to get data about the current user. And then you can also have a path  /users/{user_id}  to get data about a specific user by some user ID. Because  path operations  are evaluated in order, you need to make sure that the path for  /users/me  is declared before the one for  /users/{user_id} : Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/users/me" ) async   def   read_user_me (): return   { "user_id" :   "the current user" } @app . get ( "/users/ {user_id} " ) async   def   read_user ( user_id :   str ): return   { "user_id" :   user_id } Otherwise, the path for  /users/{user_id}  would match also for  /users/me , "thinking" that it's receiving a parameter  user_id  with a value of  "me" . Similarly, you cannot redefine a path operation: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/users" ) async   def   read_users (): return   [ "Rick" ,   "Morty" ] @app . get ( "/users" ) async   def   read_users2 (): return   [ "Bean" ,   "Elfo" ] The first one will always be used since the path matches first. Predefined values ¬∂ If you have a  path operation  that receives a  path parameter , but you want the possible valid  path parameter  values to be predefined, you can use a standard Python  Enum . Create an  Enum  class ¬∂ Import  Enum  and create a sub-class that inherits from  str  and from  Enum . By inheriting from  str  the API docs will be able to know that the values must be of type  string  and will be able to render correctly. Then create class attributes with fixed values, which will be the available valid values: Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   "alexnet" resnet   =   "resnet" lenet   =   "lenet" app   =   FastAPI () @app . get ( "/models/ {model_name} " ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { "model_name" :   model_name ,   "message" :   "Deep Learning FTW!" } if   model_name . value   ==   "lenet" : return   { "model_name" :   model_name ,   "message" :   "LeCNN all the images" } return   { "model_name" :   model_name ,   "message" :   "Have some residuals" } Tip If you are wondering, "AlexNet", "ResNet", and "LeNet" are just names of Machine Learning  models . Declare a  path parameter ¬∂ Then create a  path parameter  with a type annotation using the enum class you created ( ModelName ): Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   "alexnet" resnet   =   "resnet" lenet   =   "lenet" app   =   FastAPI () @app . get ( "/models/ {model_name} " ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { "model_name" :   model_name ,   "message" :   "Deep Learning FTW!" } if   model_name . value   ==   "lenet" : return   { "model_name" :   model_name ,   "message" :   "LeCNN all the images" } return   { "model_name" :   model_name ,   "message" :   "Have some residuals" } Check the docs ¬∂ Because the available values for the  path parameter  are predefined, the interactive docs can show them nicely: Working with Python  enumerations ¬∂ The value of the  path parameter  will be an  enumeration member . Compare  enumeration members ¬∂ You can compare it with the  enumeration member  in your created enum  ModelName : Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   "alexnet" resnet   =   "resnet" lenet   =   "lenet" app   =   FastAPI () @app . get ( "/models/ {model_name} " ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { "model_name" :   model_name ,   "message" :   "Deep Learning FTW!" } if   model_name . value   ==   "lenet" : return   { "model_name" :   model_name ,   "message" :   "LeCNN all the images" } return   { "model_name" :   model_name ,   "message" :   "Have some residuals" } Get the  enumeration value ¬∂ You can get the actual value (a  str  in this case) using  model_name.value , or in general,  your_enum_member.value : Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   "alexnet" resnet   =   "resnet" lenet   =   "lenet" app   =   FastAPI () @app . get ( "/models/ {model_name} " ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { "model_name" :   model_name ,   "message" :   "Deep Learning FTW!" } if   model_name . value   ==   "lenet" : return   { "model_name" :   model_name ,   "message" :   "LeCNN all the images" } return   { "model_name" :   model_name ,   "message" :   "Have some residuals" } Tip You could also access the value  "lenet"  with  ModelName.lenet.value . Return  enumeration members ¬∂ You can return  enum members  from your  path operation , even nested in a JSON body (e.g. a  dict ). They will be converted to their corresponding values (strings in this case) before returning them to the client: Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   "alexnet" resnet   =   "resnet" lenet   =   "lenet" app   =   FastAPI () @app . get ( "/models/ {model_name} " ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { "model_name" :   model_name ,   "message" :   "Deep Learning FTW!" } if   model_name . value   ==   "lenet" : return   { "model_name" :   model_name ,   "message" :   "LeCNN all the images" } return   { "model_name" :   model_name ,   "message" :   "Have some residuals" } In your client you will get a JSON response like: { "model_name" :   "alexnet" , "message" :   "Deep Learning FTW!" } Path parameters containing paths ¬∂ Let's say you have a  path operation  with a path  /files/{file_path} . But you need  file_path  itself to contain a  path , like  home/johndoe/myfile.txt . So, the URL for that file would be something like:  /files/home/johndoe/myfile.txt . OpenAPI support ¬∂ OpenAPI doesn't support a way to declare a  path parameter  to contain a  path  inside, as that could lead to scenarios that are difficult to test and define. Nevertheless, you can still do it in  FastAPI , using one of the internal tools from Starlette. And the docs would still work, although not adding any documentation telling that the parameter should contain a path. Path convertor ¬∂ Using an option directly from Starlette you can declare a  path parameter  containing a  path  using a URL like: /files/{file_path:path} In this case, the name of the parameter is  file_path , and the last part,  :path , tells it that the parameter should match any  path . So, you can use it with: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/files/{file_path:path}" ) async   def   read_file ( file_path :   str ): return   { "file_path" :   file_path } Tip You might need the parameter to contain  /home/johndoe/myfile.txt , with a leading slash ( / ). In that case, the URL would be:  /files//home/johndoe/myfile.txt , with a double slash ( // ) between  files  and  home . Recap ¬∂ With  FastAPI , by using short, intuitive and standard Python type declarations, you get: Editor support: error checks, autocompletion, etc. Data " parsing " Data validation API annotation and automatic documentation And you only have to declare them once. That's probably the main visible advantage of  FastAPI  compared to alternative frameworks (apart from the raw performance). Back to top



===== SOURCE URL =====
https://fastapi.tiangolo.com/tutorial/query-params/
===== PAGE CONTENT =====
Query Parameters - FastAPI Skip to content Query Parameters ¬∂ When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters. Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () fake_items_db   =   [{ "item_name" :   "Foo" },   { "item_name" :   "Bar" },   { "item_name" :   "Baz" }] @app . get ( "/items/" ) async   def   read_item ( skip :   int   =   0 ,   limit :   int   =   10 ): return   fake_items_db [ skip   :   skip   +   limit ] The query is the set of key-value pairs that go after the  ?  in a URL, separated by  &  characters. For example, in the URL: http://127.0.0.1:8000/items/?skip=0&limit=10 ...the query parameters are: skip : with a value of  0 limit : with a value of  10 As they are part of the URL, they are "naturally" strings. But when you declare them with Python types (in the example above, as  int ), they are converted to that type and validated against it. All the same process that applied for path parameters also applies for query parameters: Editor support (obviously) Data  "parsing" Data validation Automatic documentation Defaults ¬∂ As query parameters are not a fixed part of a path, they can be optional and can have default values. In the example above they have default values of  skip=0  and  limit=10 . So, going to the URL: http://127.0.0.1:8000/items/ would be the same as going to: http://127.0.0.1:8000/items/?skip=0&limit=10 But if you go to, for example: http://127.0.0.1:8000/items/?skip=20 The parameter values in your function will be: skip=20 : because you set it in the URL limit=10 : because that was the default value Optional parameters ¬∂ The same way, you can declare optional query parameters, by setting their default to  None : Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id :   str ,   q :   str   |   None   =   None ): if   q : return   { "item_id" :   item_id ,   "q" :   q } return   { "item_id" :   item_id } ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id :   str ,   q :   Union [ str ,   None ]   =   None ): if   q : return   { "item_id" :   item_id ,   "q" :   q } return   { "item_id" :   item_id } In this case, the function parameter  q  will be optional, and will be  None  by default. Check Also notice that  FastAPI  is smart enough to notice that the path parameter  item_id  is a path parameter and  q  is not, so, it's a query parameter. Query parameter type conversion ¬∂ You can also declare  bool  types, and they will be converted: Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id :   str ,   q :   str   |   None   =   None ,   short :   bool   =   False ): item   =   { "item_id" :   item_id } if   q : item . update ({ "q" :   q }) if   not   short : item . update ( { "description" :   "This is an amazing item that has a long description" } ) return   item ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_item ( item_id :   str ,   q :   Union [ str ,   None ]   =   None ,   short :   bool   =   False ): item   =   { "item_id" :   item_id } if   q : item . update ({ "q" :   q }) if   not   short : item . update ( { "description" :   "This is an amazing item that has a long description" } ) return   item In this case, if you go to: http://127.0.0.1:8000/items/foo?short=1 or http://127.0.0.1:8000/items/foo?short=True or http://127.0.0.1:8000/items/foo?short=true or http://127.0.0.1:8000/items/foo?short=on or http://127.0.0.1:8000/items/foo?short=yes or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter  short  with a  bool  value of  True . Otherwise as  False . Multiple path and query parameters ¬∂ You can declare multiple path parameters and query parameters at the same time,  FastAPI  knows which is which. And you don't have to declare them in any specific order. They will be detected by name: Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/users/ {user_id} /items/ {item_id} " ) async   def   read_user_item ( user_id :   int ,   item_id :   str ,   q :   str   |   None   =   None ,   short :   bool   =   False ): item   =   { "item_id" :   item_id ,   "owner_id" :   user_id } if   q : item . update ({ "q" :   q }) if   not   short : item . update ( { "description" :   "This is an amazing item that has a long description" } ) return   item ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/users/ {user_id} /items/ {item_id} " ) async   def   read_user_item ( user_id :   int ,   item_id :   str ,   q :   Union [ str ,   None ]   =   None ,   short :   bool   =   False ): item   =   { "item_id" :   item_id ,   "owner_id" :   user_id } if   q : item . update ({ "q" :   q }) if   not   short : item . update ( { "description" :   "This is an amazing item that has a long description" } ) return   item Required query parameters ¬∂ When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required. If you don't want to add a specific value but just make it optional, set the default as  None . But when you want to make a query parameter required, you can just not declare any default value: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_user_item ( item_id :   str ,   needy :   str ): item   =   { "item_id" :   item_id ,   "needy" :   needy } return   item Here the query parameter  needy  is a required query parameter of type  str . If you open in your browser a URL like: http://127.0.0.1:8000/items/foo-item ...without adding the required parameter  needy , you will see an error like: { "detail" :   [ { "type" :   "missing" , "loc" :   [ "query" , "needy" ], "msg" :   "Field required" , "input" :   null } ] } As  needy  is a required parameter, you would need to set it in the URL: http://127.0.0.1:8000/items/foo-item?needy=sooooneedy ...this would work: { "item_id" :   "foo-item" , "needy" :   "sooooneedy" } And of course, you can define some parameters as required, some as having a default value, and some entirely optional: Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_user_item ( item_id :   str ,   needy :   str ,   skip :   int   =   0 ,   limit :   int   |   None   =   None ): item   =   { "item_id" :   item_id ,   "needy" :   needy ,   "skip" :   skip ,   "limit" :   limit } return   item ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( "/items/ {item_id} " ) async   def   read_user_item ( item_id :   str ,   needy :   str ,   skip :   int   =   0 ,   limit :   Union [ int ,   None ]   =   None ): item   =   { "item_id" :   item_id ,   "needy" :   needy ,   "skip" :   skip ,   "limit" :   limit } return   item In this case, there are 3 query parameters: needy , a required  str . skip , an  int  with a default value of  0 . limit , an optional  int . Tip You could also use  Enum s the same way as with  Path Parameters . Back to top



===== SOURCE URL =====
https://fastapi.tiangolo.com/tutorial/body/
===== PAGE CONTENT =====
Request Body - FastAPI Skip to content Request Body ¬∂ When you need to send data from a client (let's say, a browser) to your API, you send it as a  request body . A  request  body is data sent by the client to your API. A  response  body is the data your API sends to the client. Your API almost always has to send a  response  body. But clients don't necessarily need to send  request bodies  all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body. To declare a  request  body, you use  Pydantic  models with all their power and benefits. Info To send data, you should use one of:  POST  (the more common),  PUT ,  DELETE  or  PATCH . Sending a body with a  GET  request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases. As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using  GET , and proxies in the middle might not support it. Import Pydantic's  BaseModel ¬∂ First, you need to import  BaseModel  from  pydantic : Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): return   item ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): return   item Create your data model ¬∂ Then you declare your data model as a class that inherits from  BaseModel . Use standard Python types for all the attributes: Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): return   item ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): return   item The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use  None  to make it just optional. For example, this model above declares a JSON " object " (or Python  dict ) like: { "name" :   "Foo" , "description" :   "An optional description" , "price" :   45.2 , "tax" :   3.5 } ...as  description  and  tax  are optional (with a default value of  None ), this JSON " object " would also be valid: { "name" :   "Foo" , "price" :   45.2 } Declare it as a parameter ¬∂ To add it to your  path operation , declare it the same way you declared path and query parameters: Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): return   item ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): return   item ...and declare its type as the model you created,  Item . Results ¬∂ With just that Python type declaration,  FastAPI  will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data. Give you the received data in the parameter  item . As you declared it in the function to be of type  Item , you will also have all the editor support (completion, etc) for all of the attributes and their types. Generate  JSON Schema  definitions for your model, you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation  UIs . Automatic docs ¬∂ The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: And will also be used in the API docs inside each  path operation  that needs them: Editor support ¬∂ In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a  dict  instead of a Pydantic model): You also get error checks for incorrect type operations: This is not by chance, the whole framework was built around that design. And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors. There were even some changes to Pydantic itself to support this. The previous screenshots were taken with  Visual Studio Code . But you would get the same editor support with  PyCharm  and most of the other Python editors: Tip If you use  PyCharm  as your editor, you can use the  Pydantic PyCharm Plugin . It improves editor support for Pydantic models, with: auto-completion type checks refactoring searching inspections Use the model ¬∂ Inside of the function, you can access all the attributes of the model object directly: Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): item_dict   =   item . model_dump () if   item . tax   is   not   None : price_with_tax   =   item . price   +   item . tax item_dict . update ({ "price_with_tax" :   price_with_tax }) return   item_dict ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( "/items/" ) async   def   create_item ( item :   Item ): item_dict   =   item . model_dump () if   item . tax   is   not   None : price_with_tax   =   item . price   +   item . tax item_dict . update ({ "price_with_tax" :   price_with_tax }) return   item_dict Request body + path parameters ¬∂ You can declare path parameters and request body at the same time. FastAPI  will recognize that the function parameters that match path parameters should be  taken from the path , and that function parameters that are declared to be Pydantic models should be  taken from the request body . Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . put ( "/items/ {item_id} " ) async   def   update_item ( item_id :   int ,   item :   Item ): return   { "item_id" :   item_id ,   ** item . model_dump ()} ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . put ( "/items/ {item_id} " ) async   def   update_item ( item_id :   int ,   item :   Item ): return   { "item_id" :   item_id ,   ** item . model_dump ()} Request body + path + query parameters ¬∂ You can also declare  body ,  path  and  query  parameters, all at the same time. FastAPI  will recognize each of them and take the data from the correct place. Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . put ( "/items/ {item_id} " ) async   def   update_item ( item_id :   int ,   item :   Item ,   q :   str   |   None   =   None ): result   =   { "item_id" :   item_id ,   ** item . model_dump ()} if   q : result . update ({ "q" :   q }) return   result ü§ì Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . put ( "/items/ {item_id} " ) async   def   update_item ( item_id :   int ,   item :   Item ,   q :   Union [ str ,   None ]   =   None ): result   =   { "item_id" :   item_id ,   ** item . model_dump ()} if   q : result . update ({ "q" :   q }) return   result The function parameters will be recognized as follows: If the parameter is also declared in the  path , it will be used as a path parameter. If the parameter is of a  singular type  (like  int ,  float ,  str ,  bool , etc) it will be interpreted as a  query  parameter. If the parameter is declared to be of the type of a  Pydantic model , it will be interpreted as a request  body . Note FastAPI will know that the value of  q  is not required because of the default value  = None . The  str | None  (Python 3.10+) or  Union  in  Union[str, None]  (Python 3.9+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of  = None . But adding the type annotations will allow your editor to give you better support and detect errors. Without Pydantic ¬∂ If you don't want to use Pydantic models, you can also use  Body  parameters. See the docs for  Body - Multiple Parameters: Singular values in body . Back to top
