[
    {
        "id": 0,
        "text": "FastAPI â€“ Python Web Framework 29. FASTAPI â€“ FASTAPI EVENT HANDLERS ..................................................... 106 30. FASTAPI â€“ MOUNTING A SUB-APP ........................................................... 108 31. FASTAPI â€“ MIDDLEWARE ......................................................................... 111 32. FASTAPI â€“ MOUNTING FLASK APP ........................................................... 113 33. FASTAPI â€“ DEPLOYMENT ......................................................................... 115 iv\n1. FastAPI â€“ InFtasrtoAPdI â€“u Pcytthioon Wne b Framework FastAPI is a modern Python web framework, very efficient in building APIs. It is based on Pythonâ€™s type hints feature that has been added since Python 3.6 onwards. It is one of the fastest web frameworks of Python. ï‚· As it works on the functionality of Starlette and Pydantic libraries, its performance is amongst the best and on par with that of NodeJS and Go. ï‚· In addition to offering high performance, FastAPI offers significant speed for development, reduces human-induced errors in the code, is easy to learn and is completely production-ready. ï‚· FastAPI is fully compatible with well-known standards of APIs, namely OpenAPI and JSON schema. FastAPI has been developed by Sebastian Ramirez in Dec. 2018. FastAPI 0.68.0 is the currently available version. FastAPI â€“ Environment Setup To install FastAPI (preferably in a virtual environment), use pip installer. pip3 install fastapi FastAPI depends on Starlette and Pydantic libraries, hence they also get installed. Installing Uvicorn using PIP FastAPI doesnâ€™t come with any built-in server application. To run FastAPI app, you need an ASGI server called uvicorn, so install the same too, using pip installer. It will also install uvicornâ€™s dependencies - asgiref, click, h11, and typing-extensions pip3 install uvicorn With these two libraries installed, we can check all the libraries installed so far. 1\nFastAPI â€“ Python Web Framework pip3 freeze asgiref==3.4.1 click==8.0.1 colorama==0.4.4 fastapi==0.68.0 h11==0.12.0 importlib-metadata==4.6.4 pydantic==1.8.2 starlette==0.14.2 typing-extensions==3.10.0.0"
    },
    {
        "id": 1,
        "text": "0.68.0 h11==0.12.0 importlib-metadata==4.6.4 pydantic==1.8.2 starlette==0.14.2 typing-extensions==3.10.0.0 uvicorn==0.15.0 zipp==3.5.0 2\n2. FastAPI â€“ HFeasltlAoPI â€“W Pyothornl dWe b Framework Getting Started The first step in creating a FastAPI app is to declare the application object of FastAPI class. from fastapi import FastAPI app = FastAPI() This app object is the main point of interaction of the application with the client browser. The uvicorn server uses this object to listen to clientâ€™s request. The next step is to create path operation. Path is a URL which when visited by the client invokes visits a mapped URL to one of the HTTP methods, an associated function is to be executed. We need to bind a view function to a URL and the corresponding HTTP method. For example, the index() function corresponds to â€˜/â€™ path with â€˜getâ€™ operation. @app.get(\"/\") async def root(): return {\"message\": \"Hello World\"} The function returns a JSON response, however, it can return dict, list, str, int, etc. It can also return Pydantic models. Save the following code as main.py from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def index(): return {\"message\": \"Hello World\"} 3\nFastAPI â€“ Python Web Framework Start the uvicorn server by mentioning the file in which the FastAPI application object is instantiated. uvicorn main:app --reload INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [28720] INFO: Started server process [28722] INFO: Waiting for application startup. INFO: Application startup complete. Open the browser and visit http://localhost:/8000. You will see the JSON response in the browser window. 4\n3. FastAPI â€“ FOastpAPeI â€“n PAythPonI Web Framework Enter the following URL in the browser to generate automatically the interactive documentation. http://127.0.0.1:8000/docs FastAPI uses Swagger UI to produce this documentation. The browser will display the following: 5\nFastAPI â€“ Python"
    },
    {
        "id": 2,
        "text": " the following URL in the browser to generate automatically the interactive documentation. http://127.0.0.1:8000/docs FastAPI uses Swagger UI to produce this documentation. The browser will display the following: 5\nFastAPI â€“ Python Web Framework Click the 'try it out' button and then 'Execute' button that appears afterward. You can see the Curl command internally executed, the request URL, the response headers, and the JSON format of the serverâ€™s response. FastAPI generates a schema using OpenAPI specifications. The specification determines how to define API paths, path parameters, etc. The API schema defined by the OpenAPI standard decides how the data is sent 6\nFastAPI â€“ Python Web Framework using JSON Schema. Visit http://127.0.0.1:8000/openapi.json from your browser. A neatly formatted JSON response as follows will be displayed: { \"openapi\": \"3.0.2\", \"info\": { \"title\": \"FastAPI\", \"version\": \"0.1.0\" }, \"paths\": { \"/\": { \"get\": { \"summary\": \"Index\", \"operationId\": \"index__get\", \"responses\": { \"200\": { \"description\": \"Successful Response\", \"content\": { \"application/json\": { \"schema\": {} } } } } } } } } FastAPI also supports another automatic documentation method provided by Redoc (https://github.com/Redocly/redoc). 7\nFastAPI â€“ Python Web Framework Enter http://localhost:8000/redoc as URL in the browserâ€™s address bar. 8\n4. FastAPI â€“F aUstAvPIi câ€“ oPyrthnon Web Framework Unlike the Flask framework, FastAPI doesnâ€™t contain any built-in development server. Hence we need Uvicorn. It implements ASGI standards and is lightning fast. ASGI stands for Asynchronous Server Gateway Interface. The WSGI (Web Server Gateway Interface â€“ the older standard) compliant web servers are not suitable for asyncio applications. Python web frameworks (such as FastAPI) implementing ASGI specifications provide high speed performance, comparable to web apps built with Node and Go. Uvicorn uses uvloop and httptools libraries. It also provides support for HTTP/2 and WebSockets, which cannot be handled by WSGI. uvloop id similar to the built-in asyncio event loop. httptools library handles the http protocols"
    },
    {
        "id": 3,
        "text": " uvloop and httptools libraries. It also provides support for HTTP/2 and WebSockets, which cannot be handled by WSGI. uvloop id similar to the built-in asyncio event loop. httptools library handles the http protocols. The installation of Uvicorn as described earlier will install it with minimal dependencies. However, standard installation will also install cython based dependencies along with other additional libraries. pip3 install uvicorn(standard) With this, the WebSockets protocol will be supported. Also, PyYAML will be installed to allow you to provide a .yaml file. As mentioned earlier, the application is launched on the Uvicorn server with the following command: uvicorn main:app â€“reload The --reload option enables the debug mode so that any changes in app.py will be automatically reflected and the display on the client browser will be automatically refreshed. In addition, the following command-line options may be used: --host TEXT B i nd socket to this host. [default 127.0.0.1] --port INTEGER B i n d socket to this port. [default 8000] --uds TEXT B i nd to a UNIX domain socket. --fd INTEGER B i n d to socket from this file descriptor. --reload Enable auto-reload. 9\nFastAPI â€“ Python Web Framework Set reload directories explicitly, default --reload-dir PATH current working directory. Include files while watching. Includes '*.py' by --reload-include TEXT default -reload-exclude TEXT E x c lu de while watching for files. Delay between previous and next check default --reload-delay FLOAT 0.25 -loop Event loop implementation. [default auto] [auto|asyncio|uvloop] --http HTTP protocol implementation. [default auto] [auto|h11|httptools] --interface Select application interface. [default auto] auto|asgi|asgi|wsgi --env-file PATH E n vironment configuration file. Logging configuration file. Supported formats --log-config PATH .ini, .json, .yaml. --version D isplay the uvicorn version and exit. Look for APP in the specified directory default --app-dir TEXT current directory --help Show this message and exit. Instead of starting Uvicorn server from command line, it can be launched programmatically also. Example In the Python code, call uvicorn.run() method, using any of the parameters listed above: import uvicorn from"
    },
    {
        "id": 4,
        "text": " Show this message and exit. Instead of starting Uvicorn server from command line, it can be launched programmatically also. Example In the Python code, call uvicorn.run() method, using any of the parameters listed above: import uvicorn from fastapi import FastAPI app = FastAPI() @app.get(\"/\") 10\nFastAPI â€“ Python Web Framework async def index(): return {\"message\": \"Hello World\"} if __name__ == \"__main__\": uvicorn.run(\"main:app\", host=\"127.0.0.1\", port=8000, reload=True) Now run this app.py as Python script as follows: (fastapienv) C:\\fastapienv>python app.py Uvicorn server will thus be launched in debug mode. 11\n5. FastAPI â€“ TFaystpAPeI â€“H Pyitnhotns W eb Framework FastAPI makes extensive use of the Type hinting feature made available in Pythonâ€™s version 3.5 onwards. As a matter of fact, Python is known to be a dynamically typed language. It also happens to be Pythonâ€™s distinct feature. In a Python code, a variable need not be declared to be belonging to a certain type, and its type is determined dynamically by the instantaneous value assigned to it. Pythonâ€™s interpreter doesnâ€™t perform type checks and hence it is prone to runtime exceptions. In the following example, a division() function is defined with two parameters and returns their division, assuming that the parameters will be numeric. >>> def division(a, b): return a/b >>> division(10, 4) 2.5 >>> division(10, 2.5) 4.0 However, if one of the values passed to the function happen to be non- numeric, it results in TypeError as shown below: >>> division(\"Python\",5) TypeError: unsupported operand type(s) for /: 'str' and 'int' Even a basic coding environment such as IDLE indicates that the function requires two parameters but wonâ€™t specify the types as they havenâ€™t been declared. 12\nFastAPI â€“ Python Web Framework Pythonâ€™s new type hinting feature helps in prompting the user with the expected type of the parameters to be passed. This is done by adding a colon and data type after the parameter. Weâ€™ll redefine the division() function as follows: Note that while calling the function, Python hints at the expected type of each parameter to be passed. However,"
    },
    {
        "id": 5,
        "text": " to be passed. This is done by adding a colon and data type after the parameter. Weâ€™ll redefine the division() function as follows: Note that while calling the function, Python hints at the expected type of each parameter to be passed. However, this doesnâ€™t prevent the TypeError from appearing if an incompatible value is passed. You will have to use a static type checker such as MyPy to check for compatibility before running. Just as the formal parameters in the functionâ€™s definition, it is possible to provide type hint for a functionâ€™s return value. Just before the colon symbol in the functionâ€™s definition statement (after which the function block starts) add an arrow (->) and the type. However, as mentioned earlier, if incompatible values are passed to the function, or returned by the function, Python reports TypeError. Use of MyPy static type checker can detect such errors. Install mypy package first. 13\nFastAPI â€“ Python Web Framework pip3 install mypy Save the following code as typecheck.py def division(x:int, y:int) -> int: return (x//y) a=division(10,2) print (a) b=division(5,2.5) print (b) c=division(\"Hello\",10) print (c) Check this code for type errors using mypy. C:\\python37>mypy typechk.py typechk.py:7: error: Argument 2 to \"division\" has incompatible type \"float\"; expected \"int\" typechk.py:10: error: Argument 1 to \"division\" has incompatible type \"str\"; expected \"int\" Found 2 errors in 1 file (checked 1 source file) There are errors in second and third calls to the function. In second, value passed to y is float when int is expected. In third, value passed to x is str when int is expected. (Note that // operator returns integer division) All standard data types can be used as type hints. This can be done with global variables, variables as function parameters, inside function definition etc. x: int = 3 y: float = 3.14 14\nFastAPI â€“ Python Web Framework nm: str = 'abc' married: bool = False names: list = ['a', 'b', 'c'] marks: tuple = (10, 20, 30) marklist: dict = {'a': 10, 'b': 20, '"
    },
    {
        "id": 6,
        "text": "' married: bool = False names: list = ['a', 'b', 'c'] marks: tuple = (10, 20, 30) marklist: dict = {'a': 10, 'b': 20, 'c': 30} A new addition in newer versions of Python (version 3.5 onwards) standard library is the typing module. It defines special types for corresponding standard collection types. The types on typing module are List, Tuple, Dict, and Sequence. It also consists of Union and Optional types. Note that standard names of data types are all in small case, whereas ones in typing module have first letter in upper case. Using this feature, we can ask a collection of a particular type. from typing import List, Tuple, Dict # following line declares a List object of strings. # If violated, mypy shows error cities: List[str] = ['Mumbai', 'Delhi', 'Chennai'] # This is Tuple with three elements respectively # of str, int and float type) employee: Tuple[str, int, float] = ('Ravi', 25, 35000) # Similarly in the following Dict, the object key should be str # and value should be of int type, failing which # static type checker throws error marklist: Dict[str, int] = {'Ravi': 61, 'Anil': 72} 15\n6. FastAPI â€“ IDFaEst ASPIu â€“ pPypthoonr Wte b Framework The Type Hinting feature of Python is most effectively used in almost all IDEs (Integrated Development Environments) such as PyCharm and VS Code to provide dynamic autocomplete features. Let us see how VS Code uses the type hints to provide autocomplete suggestions while writing a code. In the example below, a function named as sayhello with name as an argument has been defined. The function returns a string by concatenating â€œHelloâ€ to the name parameter by adding a space in between. Additionally, it is required to ensure that the first letter of the name be in upper case. Pythonâ€™s str class has a capitalize() method for the purpose, but if one doesnâ€™t remember it while typing the code, one has to search for it elsewhere. If you give a dot after name, you expect the list of attributes but nothing is shown because Python doesnâ€™t know what will be the runtime type of name variable. Here, type hint comes handy."
    },
    {
        "id": 7,
        "text": " code, one has to search for it elsewhere. If you give a dot after name, you expect the list of attributes but nothing is shown because Python doesnâ€™t know what will be the runtime type of name variable. Here, type hint comes handy. Include str as the type of name in the function definition. Now when you press dot (.) after name, a drop down list of all string methods appears, from which the required method (in this case capitalize()) can be picked. 16\nFastAPI â€“ Python Web Framework It is also possible to use type hints with a user defined class. In the following example a rectangle class is defined with type hints for arguments to the __init__() constructor. class rectangle: def __init__(self, w:int, h:int) ->None: self.width=w self.height=h Following is a function that uses an object of above rectangle class as an argument. The type hint used in the declaration is the name of the class. def area(r:rectangle)->int: return r.width*r.height r1=rectangle(10,20) print (\"area = \", area(r1)) In this case also, the IDE editor provides autocomplete support prompting list of the instance attributes. Following is a screenshot of PyCharm editor. 17\nFastAPI â€“ Python Web Framework FastAPI makes extensive use of the type hints. This feature is found everywhere, such as path parameters, query parameters, headers, bodies, dependencies, etc. as well as validating the data from the incoming request. The OpenAPI document generation also uses type hints. 18\n7. FastAPI â€“ RESTFa sAtArPIc â€“h Piyttheocn tWuebr Fera mework RElational State Transfer (REST) is a software architectural style. REST defines how the architecture of a web application should behave. It is a resource based architecture where everything that the REST server hosts, (a file, an image, or a row in a table of a database), is a resource, having many representations. REST recommends certain architectural constraints. ï‚· Uniform interface ï‚· Statelessness ï‚· Client-server ï‚· Cacheability ï‚· Layered system ï‚· Code on demand REST constraints has the following advantages: ï‚· Scalability ï‚· Simplicity ï‚· Modifiability ï‚· Reliability ï‚· Portability ï‚· Visibility REST uses HTTP verbs or methods for the operation on the resources. The POST, GET, PUT and DELETE methods perform respectively"
    },
    {
        "id": 8,
        "text": ": ï‚· Scalability ï‚· Simplicity ï‚· Modifiability ï‚· Reliability ï‚· Portability ï‚· Visibility REST uses HTTP verbs or methods for the operation on the resources. The POST, GET, PUT and DELETE methods perform respectively CREATE, READ, UPDATE and DELETE operations respectively. 19\n8. FastAPI â€“ PathFa sPtAaPI râ€“a Pmythoen tWeebr sFr amework Modern web frameworks use routes or endpoints as a part of URL instead of file-based URLs. This helps the user to remember the application URLs more effectively. In FastAPI, it is termed a path. A path or route is the part of the URL trailing after the first â€˜/â€™. For example, in the following URL, http://localhost:8000/hello/TutorialsPoint the path or the route would be /hello/TutorialsPoint In FastAPI, such a path string is given as a parameter to the operation decorator. The operation here refers to the HTTP verb used by the browser to send the data. These operations include GET, PUT, etc. The operation decorator (for example, @app.get(\"/\")) is immediately followed by a function that is executed when the specified URL is visited. In the below example: from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def index(): return {\"message\": \"Hello World\"} Here, (\"/\") is the path, get is the operation, @app.get(\"/\") is the path operation decorator, and the index() function just below it is termed as path operation function. Any of the following HTTP verbs can be used as operations. Sends data in unencrypted form to the server. Most GET common method. HEAD Same as GET, but without the response body. 20\nFastAPI â€“ Python Web Framework Used to send HTML form data to the server. Data received POST by the POST method is not cached by the server. Replaces all current representations of the target resource PUT with the uploaded content. Removes all current representations of the target resource DELETE given by a URL. The async keyword in the functionâ€™s definition tells FastAPI that it is to be run asynchronously i.e. without blocking the current thread of execution. However, a path operation function can be defined without the async prefix also. This decorated function returns a JSON response. Although it can return almost any of Pythonâ€™s objects, it will be automatically converted to JSON. Further in this tutorial, we shall see how"
    },
    {
        "id": 9,
        "text": ", a path operation function can be defined without the async prefix also. This decorated function returns a JSON response. Although it can return almost any of Pythonâ€™s objects, it will be automatically converted to JSON. Further in this tutorial, we shall see how such a function returns Pydantic model objects. The URLâ€™s endpoint or path can have one or more variable parameters. They can be accepted by using Pythonâ€™s string formatting notation. In the above example URL http://localhost:8000/hello/TutorialsPoint, the last value may change in every client request. This variable parameter can be accepted in a variable as defined in the path and passed to the formal parameters defined in the function bound to the operation decorator. Example Add another path decorator with a variable parameter in the route, and bind hello() function to have name parameter. Modify the main.py as per the following. import uvicorn from fastapi import FastAPI app = FastAPI() @app.get(\"/\") async def index(): return {\"message\": \"Hello World\"} @app.get(\"/hello/{name}\") 21\nFastAPI â€“ Python Web Framework async def hello(name): return {\"name\": name} Start the Uvicorn server and visit http://localhost:8000/hello/Tutorialspoint URL. The browser shows the following JSON response. {\"name\":\"Tutorialspoint\"} Change the variable path parameter to something else such as http://localhost:8000/hello/Python so that the browser shows: {\"name\":\"Python\"} Check OpenAPI docs Now if we check the OpenAPI documentation by entering the URL as http://localhost:8000/docs, it will show two routes and their respective view functions. Click the try out button below /hello/{name} button and give Tutorialspoint as the value of the name parameterâ€™s description and then click the Execute button. 22\nFastAPI â€“ Python Web Framework It will then show the Curl command, the request URL and the details of serverâ€™s response with response body and response headers. 23\nFastAPI â€“ Python Web Framework A route can have multiple parameters separated by \"/\" symbol. from fastapi import FastAPI app = FastAPI() @app.get(\"/hello/{name}/{age}\") async def hello(name,age): 24\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/\n===== PAGE CONTENT =====\nFastAPI Skip to content FastAPI Â¶ FastAPI framework, high performance, easy to learn, fast to code, ready for production"
    },
    {
        "id": 10,
        "text": "age): 24\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/\n===== PAGE CONTENT =====\nFastAPI Skip to content FastAPI Â¶ FastAPI framework, high performance, easy to learn, fast to code, ready for production Documentation :  https://fastapi.tiangolo.com Source Code :  https://github.com/fastapi/fastapi FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. The key features are: Fast : Very high performance, on par with  NodeJS  and  Go  (thanks to Starlette and Pydantic).  One of the fastest Python frameworks available . Fast to code : Increase the speed to develop features by about 200% to 300%. * Fewer bugs : Reduce about 40% of human (developer) induced errors. * Intuitive : Great editor support.  Completion  everywhere. Less time debugging. Easy : Designed to be easy to use and learn. Less time reading docs. Short : Minimize code duplication. Multiple features from each parameter declaration. Fewer bugs. Robust : Get production-ready code. With automatic interactive documentation. Standards-based : Based on (and fully compatible with) the open standards for APIs:  OpenAPI  (previously known as Swagger) and  JSON Schema . * estimation based on tests conducted by an internal development team, building production applications. Sponsors Â¶ Keystone Sponsor Â¶ Gold and Silver Sponsors Â¶ Other sponsors Opinions Â¶ \" [...] I'm using  FastAPI  a ton these days. [...] I'm actually planning to use it for all of my team's  ML services at Microsoft . Some of them are getting integrated into the core  Windows  product and some  Office  products. \" Kabir Khan -  Microsoft   (ref) \" We adopted the  FastAPI  library to spawn a  REST  server that can be queried to obtain  predictions . [for Ludwig] \" Piero Molino, Yaroslav Dudin, and Sai Sumanth Miryala -  Uber   (ref) \" Netflix  is pleased to announce the open-source release of our  crisis management  orchestration framework:  Dispatch ! [built with  FastAPI ] \" Kevin Glisson, Marc Vilanova, Forest Monsen -  Netflix   (ref) \" Iâ€™m over the moon excited about  FastAPI . Itâ€™s so fun! \" Brian Okken -"
    },
    {
        "id": 11,
        "text": " Dispatch ! [built with  FastAPI ] \" Kevin Glisson, Marc Vilanova, Forest Monsen -  Netflix   (ref) \" Iâ€™m over the moon excited about  FastAPI . Itâ€™s so fun! \" Brian Okken -  Python Bytes  podcast host   (ref) \" Honestly, what you've built looks super solid and polished. In many ways, it's what I wanted  Hug  to be - it's really inspiring to see someone build that. \" Timothy Crosley -  Hug  creator   (ref) \" If you're looking to learn one  modern framework  for building REST APIs, check out  FastAPI  [...] It's fast, easy to use and easy to learn [...] \" \" We've switched over to  FastAPI  for our  APIs  [...] I think you'll like it [...] \" Ines Montani - Matthew Honnibal -  Explosion AI  founders -  spaCy  creators   (ref)  -  (ref) \" If anyone is looking to build a production Python API, I would highly recommend  FastAPI . It is  beautifully designed ,  simple to use  and  highly scalable , it has become a  key component  in our API first development strategy and is driving many automations and services such as our Virtual TAC Engineer. \" Deon Pillsbury -  Cisco   (ref) FastAPI mini documentary Â¶ There's a  FastAPI mini documentary  released at the end of 2025, you can watch it online: Typer , the FastAPI of CLIs Â¶ If you are building a  CLI  app to be used in the terminal instead of a web API, check out  Typer . Typer  is FastAPI's little sibling. And it's intended to be the  FastAPI of CLIs . âŒ¨ï¸ ğŸš€ Requirements Â¶ FastAPI stands on the shoulders of giants: Starlette  for the web parts. Pydantic  for the data parts. Installation Â¶ Create and activate a  virtual environment  and then install FastAPI: $  pip   install   \"fastapi[standard]\" ---> 100% Note : Make sure you put  \"fastapi[standard]\"  in quotes to ensure it works in all terminals. Example Â¶ Create it Â¶ Create a file  main.py  with: from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI ()"
    },
    {
        "id": 12,
        "text": "standard]\"  in quotes to ensure it works in all terminals. Example Â¶ Create it Â¶ Create a file  main.py  with: from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) def   read_root (): return   { \"Hello\" :   \"World\" } @app . get ( \"/items/ {item_id} \" ) def   read_item ( item_id :   int ,   q :   Union [ str ,   None ]   =   None ): return   { \"item_id\" :   item_id ,   \"q\" :   q } Or use  async def ... If your code uses  async  /  await , use  async def : from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   read_root (): return   { \"Hello\" :   \"World\" } @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id :   int ,   q :   Union [ str ,   None ]   =   None ): return   { \"item_id\" :   item_id ,   \"q\" :   q } Note : If you don't know, check the  \"In a hurry?\"  section about  async  and  await  in the docs . Run it Â¶ Run the server with: $  fastapi   dev   main.py â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI CLI - Development mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚                                                     â”‚ â”‚  Serving at: http://127.0.0.1:8000                  â”‚ â”‚                                                     â”‚ â”‚  API docs: http://127.0.0.1:8000/docs               â”‚ â”‚                                                     â”‚ â”‚  Running in development mode, for production use:   â”‚ â”‚                                                     â”‚ â”‚  fastapi run                                        â”‚ â”‚                                                     â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp'] INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO:     Started reloader process [2248755] using WatchFiles INFO:     Started server process [2248757] INFO:     Waiting for application startup. INFO:"
    },
    {
        "id": 13,
        "text": ".0.1:8000 (Press CTRL+C to quit) INFO:     Started reloader process [2248755] using WatchFiles INFO:     Started server process [2248757] INFO:     Waiting for application startup. INFO:     Application startup complete. About the command  fastapi dev main.py ... The command  fastapi dev  reads your  main.py  file, detects the  FastAPI  app in it, and starts a server using  Uvicorn . By default,  fastapi dev  will start with auto-reload enabled for local development. You can read more about it in the  FastAPI CLI docs . Check it Â¶ Open your browser at  http://127.0.0.1:8000/items/5?q=somequery . You will see the JSON response as: { \"item_id\" :   5 ,   \"q\" :   \"somequery\" } You already created an API that: Receives HTTP requests in the  paths   /  and  /items/{item_id} . Both  paths  take  GET   operations  (also known as HTTP  methods ). The  path   /items/{item_id}  has a  path parameter   item_id  that should be an  int . The  path   /items/{item_id}  has an optional  str   query parameter   q . Interactive API docs Â¶ Now go to  http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by  Swagger UI ): Alternative API docs Â¶ And now, go to  http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by  ReDoc ): Example upgrade Â¶ Now modify the file  main.py  to receive a body from a  PUT  request. Declare the body using standard Python types, thanks to Pydantic. from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel app   =   FastAPI () class   Item ( BaseModel ): name :   str price :   float is_offer :   Union [ bool ,   None ]   =   None @app . get ( \"/\" ) def   read_root (): return   { \"Hello\" :   \"World\" } @app . get ( \"/items/ {item_id} \" ) def   read_item ("
    },
    {
        "id": 14,
        "text": "   None ]   =   None @app . get ( \"/\" ) def   read_root (): return   { \"Hello\" :   \"World\" } @app . get ( \"/items/ {item_id} \" ) def   read_item ( item_id :   int ,   q :   Union [ str ,   None ]   =   None ): return   { \"item_id\" :   item_id ,   \"q\" :   q } @app . put ( \"/items/ {item_id} \" ) def   update_item ( item_id :   int ,   item :   Item ): return   { \"item_name\" :   item . name ,   \"item_id\" :   item_id } The  fastapi dev  server should reload automatically. Interactive API docs upgrade Â¶ Now go to  http://127.0.0.1:8000/docs . The interactive API documentation will be automatically updated, including the new body: Click on the button \"Try it out\", it allows you to fill the parameters and directly interact with the API: Then click on the \"Execute\" button, the user interface will communicate with your API, send the parameters, get the results and show them on the screen: Alternative API docs upgrade Â¶ And now, go to  http://127.0.0.1:8000/redoc . The alternative documentation will also reflect the new query parameter and body: Recap Â¶ In summary, you declare  once  the types of parameters, body, etc. as function parameters. You do that with standard modern Python types. You don't have to learn a new syntax, the methods or classes of a specific library, etc. Just standard  Python . For example, for an  int : item_id :   int or for a more complex  Item  model: item :   Item ...and with that single declaration you get: Editor support, including: Completion. Type checks. Validation of data: Automatic and clear errors when the data is invalid. Validation even for deeply nested JSON objects. Conversion  of input data: coming from the network to Python data and types. Reading from: JSON. Path parameters. Query parameters. Cookies. Headers. Forms. Files. Conversion  of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str ,  int ,  float ,  bool ,  list , etc). datetime  objects. UUID  objects. Database models. ..."
    },
    {
        "id": 15,
        "text": "  of output data: converting from Python data and types to network data (as JSON): Convert Python types ( str ,  int ,  float ,  bool ,  list , etc). datetime  objects. UUID  objects. Database models. ...and many more. Automatic interactive API documentation, including 2 alternative user interfaces: Swagger UI. ReDoc. Coming back to the previous code example,  FastAPI  will: Validate that there is an  item_id  in the path for  GET  and  PUT  requests. Validate that the  item_id  is of type  int  for  GET  and  PUT  requests. If it is not, the client will see a useful, clear error. Check if there is an optional query parameter named  q  (as in  http://127.0.0.1:8000/items/foo?q=somequery ) for  GET  requests. As the  q  parameter is declared with  = None , it is optional. Without the  None  it would be required (as is the body in the case with  PUT ). For  PUT  requests to  /items/{item_id} , read the body as JSON: Check that it has a required attribute  name  that should be a  str . Check that it has a required attribute  price  that has to be a  float . Check that it has an optional attribute  is_offer , that should be a  bool , if present. All this would also work for deeply nested JSON objects. Convert from and to JSON automatically. Document everything with OpenAPI, that can be used by: Interactive documentation systems. Automatic client code generation systems, for many languages. Provide 2 interactive documentation web interfaces directly. We just scratched the surface, but you already get the idea of how it all works. Try changing the line with: return   { \"item_name\" :   item . name ,   \"item_id\" :   item_id } ...from: ...   \"item_name\" :   item . name   ... ...to: ...   \"item_price\" :   item . price   ... ...and see how your editor will auto-complete the attributes and know their types: For a more complete example including more features, see the  Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of  parameters  from other different places as:  headers ,  cookies ,  form fields  and "
    },
    {
        "id": 16,
        "text": " a more complete example including more features, see the  Tutorial - User Guide . Spoiler alert : the tutorial - user guide includes: Declaration of  parameters  from other different places as:  headers ,  cookies ,  form fields  and  files . How to set  validation constraints  as  maximum_length  or  regex . A very powerful and easy to use  Dependency Injection  system. Security and authentication, including support for  OAuth2  with  JWT tokens  and  HTTP Basic  auth. More advanced (but equally easy) techniques for declaring  deeply nested JSON models  (thanks to Pydantic). GraphQL  integration with  Strawberry  and other libraries. Many extra features (thanks to Starlette) as: WebSockets extremely easy tests based on HTTPX and  pytest CORS Cookie Sessions ...and more. Deploy your app (optional) Â¶ You can optionally deploy your FastAPI app to  FastAPI Cloud , go and join the waiting list if you haven't. ğŸš€ If you already have a  FastAPI Cloud  account (we invited you from the waiting list ğŸ˜‰), you can deploy your application with one command. Before deploying, make sure you are logged in: $  fastapi   login You are logged in to FastAPI Cloud ğŸš€ Then deploy your app: $  fastapi   deploy Deploying to FastAPI Cloud... âœ… Deployment successful! ğŸ” Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev That's it! Now you can access your app at that URL. âœ¨ About FastAPI Cloud Â¶ FastAPI Cloud  is built by the same author and team behind  FastAPI . It streamlines the process of  building ,  deploying , and  accessing  an API with minimal effort. It brings the same  developer experience  of building apps with FastAPI to  deploying  them to the cloud. ğŸ‰ FastAPI Cloud is the primary sponsor and funding provider for the  FastAPI and friends  open source projects. âœ¨ Deploy to other cloud providers Â¶ FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose. Follow your cloud provider's guides to deploy FastAPI apps with them. ğŸ¤“ Performance Â¶ Independent TechEmpower benchmarks show  FastAPI  applications running under Uvicorn as  one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used"
    },
    {
        "id": 17,
        "text": " to deploy FastAPI apps with them. ğŸ¤“ Performance Â¶ Independent TechEmpower benchmarks show  FastAPI  applications running under Uvicorn as  one of the fastest Python frameworks available , only below Starlette and Uvicorn themselves (used internally by FastAPI). (*) To understand more about it, see the section  Benchmarks . Dependencies Â¶ FastAPI depends on Pydantic and Starlette. standard  Dependencies Â¶ When you install FastAPI with  pip install \"fastapi[standard]\"  it comes with the  standard  group of optional dependencies: Used by Pydantic: email-validator  - for email validation. Used by Starlette: httpx  - Required if you want to use the  TestClient . jinja2  - Required if you want to use the default template configuration. python-multipart  - Required if you want to support form  \"parsing\" , with  request.form() . Used by FastAPI: uvicorn  - for the server that loads and serves your application. This includes  uvicorn[standard] , which includes some dependencies (e.g.  uvloop ) needed for high performance serving. fastapi-cli[standard]  - to provide the  fastapi  command. This includes  fastapi-cloud-cli , which allows you to deploy your FastAPI application to  FastAPI Cloud . Without  standard  Dependencies Â¶ If you don't want to include the  standard  optional dependencies, you can install with  pip install fastapi  instead of  pip install \"fastapi[standard]\" . Without  fastapi-cloud-cli Â¶ If you want to install FastAPI with the standard dependencies but without the  fastapi-cloud-cli , you can install with  pip install \"fastapi[standard-no-fastapi-cloud-cli]\" . Additional Optional Dependencies Â¶ There are some additional dependencies you might want to install. Additional optional Pydantic dependencies: pydantic-settings  - for settings management. pydantic-extra-types  - for extra types to be used with Pydantic. Additional optional FastAPI dependencies: orjson  - Required if you want to use  ORJSONResponse . ujson  - Required if you want to use  UJSONResponse . License Â¶ This project is licensed under the terms of the MIT license. Back to top\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/tutorial/first-steps/\n===== PAGE CONTENT =====\nFirst Steps - FastAPI Skip to content First Steps"
    },
    {
        "id": 18,
        "text": " This project is licensed under the terms of the MIT license. Back to top\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/tutorial/first-steps/\n===== PAGE CONTENT =====\nFirst Steps - FastAPI Skip to content First Steps Â¶ The simplest FastAPI file could look like this: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   root (): return   { \"message\" :   \"Hello World\" } Copy that to a file  main.py . Run the live server: $  <font   color = \"#4E9A06\" >fastapi</font>   dev   <u   style = \"text-decoration-style:solid\" >main.py</u> <span style=\"background-color:#009485\"><font color=\"#D3D7CF\"> FastAPI </font></span>  Starting development server ğŸš€ Searching for package file structure from directories with <font color=\"#3465A4\">__init__.py</font> files Importing from <font color=\"#75507B\">/home/user/code/</font><font color=\"#AD7FA8\">awesomeapp</font> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> module </font></span>  ğŸ main.py <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> code </font></span>  Importing the FastAPI app object from the module with the following code: <u style=\"text-decoration-style:solid\">from </u><u style=\"text-decoration-style:solid\"><b>main</b></u><u style=\"text-decoration-style:solid\"> import </u><u style=\"text-decoration-style:solid\"><b>app</b></u> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> app </font></span>  Using import string: <font color=\"#3465A4\">main:app</font> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font> <span style=\"background"
    },
    {
        "id": 19,
        "text": "\"> server </font></span>  Server started at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> server </font></span>  Documentation at <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000/docs</u></font> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> tip </font></span>  Running in development mode, for production use: <b>fastapi run</b> Logs: <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Will watch for changes in these directories: <b>[</b><font color=\"#4E9A06\">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Uvicorn running on <font color=\"#729FCF\"><u style=\"text-decoration-style:solid\">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C to quit<b>)</b> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started reloader process <b>[</b><font color=\"#34E2E2\"><b>383138</b></font><b>]</b> using WatchFiles <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Started server process <b>[</b><font color=\"#34E2E2\"><b>383153</b></font><b>]</b> <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Waiting for application startup. <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete. In the output, there's a line with something like: INFO:     Uvicorn"
    },
    {
        "id": 20,
        "text": " startup. <span style=\"background-color:#007166\"><font color=\"#D3D7CF\"> INFO </font></span>  Application startup complete. In the output, there's a line with something like: INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) That line shows the URL where your app is being served, in your local machine. Check it Â¶ Open your browser at  http://127.0.0.1:8000 . You will see the JSON response as: { \"message\" :   \"Hello World\" } Interactive API docs Â¶ Now go to  http://127.0.0.1:8000/docs . You will see the automatic interactive API documentation (provided by  Swagger UI ): Alternative API docs Â¶ And now, go to  http://127.0.0.1:8000/redoc . You will see the alternative automatic documentation (provided by  ReDoc ): OpenAPI Â¶ FastAPI  generates a \"schema\" with all your API using the  OpenAPI  standard for defining APIs. \"Schema\" Â¶ A \"schema\" is a definition or description of something. Not the code that implements it, but just an abstract description. API \"schema\" Â¶ In this case,  OpenAPI  is a specification that dictates how to define a schema of your API. This schema definition includes your API paths, the possible parameters they take, etc. Data \"schema\" Â¶ The term \"schema\" might also refer to the shape of some data, like a JSON content. In that case, it would mean the JSON attributes, and data types they have, etc. OpenAPI and JSON Schema Â¶ OpenAPI defines an API schema for your API. And that schema includes definitions (or \"schemas\") of the data sent and received by your API using  JSON Schema , the standard for JSON data schemas. Check the  openapi.json Â¶ If you are curious about how the raw OpenAPI schema looks like, FastAPI automatically generates a JSON (schema) with the descriptions of all your API. You can see it directly at:  http://127.0.0.1:8000/openapi.json . It will show a JSON starting with something like: { \"openapi\" :   \"3.1.0\" , \"info\" :   { \"title\" :   \"FastAPI\" , \"version\" :"
    },
    {
        "id": 21,
        "text": "0/openapi.json . It will show a JSON starting with something like: { \"openapi\" :   \"3.1.0\" , \"info\" :   { \"title\" :   \"FastAPI\" , \"version\" :   \"0.1.0\" }, \"paths\" :   { \"/items/\" :   { \"get\" :   { \"responses\" :   { \"200\" :   { \"description\" :   \"Successful Response\" , \"content\" :   { \"application/json\" :   { ... What is OpenAPI for Â¶ The OpenAPI schema is what powers the two interactive documentation systems included. And there are dozens of alternatives, all based on OpenAPI. You could easily add any of those alternatives to your application built with  FastAPI . You could also use it to generate code automatically, for clients that communicate with your API. For example, frontend, mobile or IoT applications. Deploy your app (optional) Â¶ You can optionally deploy your FastAPI app to  FastAPI Cloud , go and join the waiting list if you haven't. ğŸš€ If you already have a  FastAPI Cloud  account (we invited you from the waiting list ğŸ˜‰), you can deploy your application with one command. Before deploying, make sure you are logged in: $  fastapi   login You are logged in to FastAPI Cloud ğŸš€ Then deploy your app: $  fastapi   deploy Deploying to FastAPI Cloud... âœ… Deployment successful! ğŸ” Ready the chicken! Your app is ready at https://myapp.fastapicloud.dev That's it! Now you can access your app at that URL. âœ¨ Recap, step by step Â¶ Step 1: import  FastAPI Â¶ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   root (): return   { \"message\" :   \"Hello World\" } FastAPI  is a Python class that provides all the functionality for your API. Technical Details FastAPI  is a class that inherits directly from  Starlette . You can use all the  Starlette  functionality with  FastAPI  too. Step 2: create a  FastAPI  \"instance\" Â¶ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async  "
    },
    {
        "id": 22,
        "text": " FastAPI  too. Step 2: create a  FastAPI  \"instance\" Â¶ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   root (): return   { \"message\" :   \"Hello World\" } Here the  app  variable will be an \"instance\" of the class  FastAPI . This will be the main point of interaction to create all your API. Step 3: create a  path operation Â¶ Path Â¶ \"Path\" here refers to the last part of the URL starting from the first  / . So, in a URL like: https://example.com/items/foo ...the path would be: /items/foo Info A \"path\" is also commonly called an \"endpoint\" or a \"route\". While building an API, the \"path\" is the main way to separate \"concerns\" and \"resources\". Operation Â¶ \"Operation\" here refers to one of the HTTP \"methods\". One of: POST GET PUT DELETE ...and the more exotic ones: OPTIONS HEAD PATCH TRACE In the HTTP protocol, you can communicate to each path using one (or more) of these \"methods\". When building APIs, you normally use these specific HTTP methods to perform a specific action. Normally you use: POST : to create data. GET : to read data. PUT : to update data. DELETE : to delete data. So, in OpenAPI, each of the HTTP methods is called an \"operation\". We are going to call them \" operations \" too. Define a  path operation decorator Â¶ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   root (): return   { \"message\" :   \"Hello World\" } The  @app.get(\"/\")  tells  FastAPI  that the function right below is in charge of handling requests that go to: the path  / using a  get  operation @decorator  Info That  @something  syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells  FastAPI  that the function below corresponds to the  path   /  with an"
    },
    {
        "id": 23,
        "text": "I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells  FastAPI  that the function below corresponds to the  path   /  with an  operation   get . It is the \" path operation decorator \". You can also use the other operations: @app.post() @app.put() @app.delete() And the more exotic ones: @app.options() @app.head() @app.patch() @app.trace() Tip You are free to use each operation (HTTP method) as you wish. FastAPI  doesn't enforce any specific meaning. The information here is presented as a guideline, not a requirement. For example, when using GraphQL you normally perform all the actions using only  POST  operations. Step 4: define the  path operation function Â¶ This is our \" path operation function \": path : is  / . operation : is  get . function : is the function below the \"decorator\" (below  @app.get(\"/\") ). Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   root (): return   { \"message\" :   \"Hello World\" } This is a Python function. It will be called by  FastAPI  whenever it receives a request to the URL \" / \" using a  GET  operation. In this case, it is an  async  function. You could also define it as a normal function instead of  async def : Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) def   root (): return   { \"message\" :   \"Hello World\" } Note If you don't know the difference, check the  Async:  \"In a hurry?\" . Step 5: return the content Â¶ Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/\" ) async   def   root (): return   { \"message\" :   \"Hello World\" } You can return a  dict ,  list , singular values as  str ,  int , etc. You can also return Pydantic models (you'll see more about that later). There are many other objects and models that will be automatically converted to JSON (including ORMs"
    },
    {
        "id": 24,
        "text": " ,  list , singular values as  str ,  int , etc. You can also return Pydantic models (you'll see more about that later). There are many other objects and models that will be automatically converted to JSON (including ORMs, etc). Try using your favorite ones, it's highly probable that they are already supported. Step 6: Deploy it Â¶ Deploy your app to  FastAPI Cloud  with one command:  fastapi deploy . ğŸ‰ About FastAPI Cloud Â¶ FastAPI Cloud  is built by the same author and team behind  FastAPI . It streamlines the process of  building ,  deploying , and  accessing  an API with minimal effort. It brings the same  developer experience  of building apps with FastAPI to  deploying  them to the cloud. ğŸ‰ FastAPI Cloud is the primary sponsor and funding provider for the  FastAPI and friends  open source projects. âœ¨ Deploy to other cloud providers Â¶ FastAPI is open source and based on standards. You can deploy FastAPI apps to any cloud provider you choose. Follow your cloud provider's guides to deploy FastAPI apps with them. ğŸ¤“ Recap Â¶ Import  FastAPI . Create an  app  instance. Write a  path operation decorator  using decorators like  @app.get(\"/\") . Define a  path operation function ; for example,  def root(): ... . Run the development server using the command  fastapi dev . Optionally deploy your app with  fastapi deploy . Back to top\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/tutorial/path-params/\n===== PAGE CONTENT =====\nPath Parameters - FastAPI Skip to content Path Parameters Â¶ You can declare path \"parameters\" or \"variables\" with the same syntax used by Python format strings: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id ): return   { \"item_id\" :   item_id } The value of the path parameter  item_id  will be passed to your function as the argument  item_id . So, if you run this example and go to  http://127.0.0.1:8000/items/foo , you will see a response of: { \"item_id\" : \"foo\" } Path parameters with types Â¶ You can declare the type of a"
    },
    {
        "id": 25,
        "text": " this example and go to  http://127.0.0.1:8000/items/foo , you will see a response of: { \"item_id\" : \"foo\" } Path parameters with types Â¶ You can declare the type of a path parameter in the function, using standard Python type annotations: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id :   int ): return   { \"item_id\" :   item_id } In this case,  item_id  is declared to be an  int . Check This will give you editor support inside of your function, with error checks, completion, etc. Data  conversion Â¶ If you run this example and open your browser at  http://127.0.0.1:8000/items/3 , you will see a response of: { \"item_id\" : 3 } Check Notice that the value your function received (and returned) is  3 , as a Python  int , not a string  \"3\" . So, with that type declaration,  FastAPI  gives you automatic request  \"parsing\" . Data validation Â¶ But if you go to the browser at  http://127.0.0.1:8000/items/foo , you will see a nice HTTP error of: { \"detail\" :   [ { \"type\" :   \"int_parsing\" , \"loc\" :   [ \"path\" , \"item_id\" ], \"msg\" :   \"Input should be a valid integer, unable to parse string as an integer\" , \"input\" :   \"foo\" } ] } because the path parameter  item_id  had a value of  \"foo\" , which is not an  int . The same error would appear if you provided a  float  instead of an  int , as in:  http://127.0.0.1:8000/items/4.2 Check So, with the same Python type declaration,  FastAPI  gives you data validation. Notice that the error also clearly states exactly the point where the validation didn't pass. This is incredibly helpful while developing and debugging code that interacts with your API. Documentation Â¶ And when you open your browser at  http://127.0.0.1:8000/docs , you"
    },
    {
        "id": 26,
        "text": " exactly the point where the validation didn't pass. This is incredibly helpful while developing and debugging code that interacts with your API. Documentation Â¶ And when you open your browser at  http://127.0.0.1:8000/docs , you will see an automatic, interactive, API documentation like: Check Again, just with that same Python type declaration,  FastAPI  gives you automatic, interactive documentation (integrating Swagger UI). Notice that the path parameter is declared to be an integer. Standards-based benefits, alternative documentation Â¶ And because the generated schema is from the  OpenAPI  standard, there are many compatible tools. Because of this,  FastAPI  itself provides an alternative API documentation (using ReDoc), which you can access at  http://127.0.0.1:8000/redoc : The same way, there are many compatible tools. Including code generation tools for many languages. Pydantic Â¶ All the data validation is performed under the hood by  Pydantic , so you get all the benefits from it. And you know you are in good hands. You can use the same type declarations with  str ,  float ,  bool  and many other complex data types. Several of these are explored in the next chapters of the tutorial. Order matters Â¶ When creating  path operations , you can find situations where you have a fixed path. Like  /users/me , let's say that it's to get data about the current user. And then you can also have a path  /users/{user_id}  to get data about a specific user by some user ID. Because  path operations  are evaluated in order, you need to make sure that the path for  /users/me  is declared before the one for  /users/{user_id} : Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/users/me\" ) async   def   read_user_me (): return   { \"user_id\" :   \"the current user\" } @app . get ( \"/users/ {user_id} \" ) async   def   read_user ( user_id :   str ): return   { \"user_id\" :   user_id } Otherwise, the path for  /users/{user_id}  would match also for  /users/me , \"thinking\" that it's receiving a parameter  user_id  with a value of  \""
    },
    {
        "id": 27,
        "text": " \"user_id\" :   user_id } Otherwise, the path for  /users/{user_id}  would match also for  /users/me , \"thinking\" that it's receiving a parameter  user_id  with a value of  \"me\" . Similarly, you cannot redefine a path operation: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/users\" ) async   def   read_users (): return   [ \"Rick\" ,   \"Morty\" ] @app . get ( \"/users\" ) async   def   read_users2 (): return   [ \"Bean\" ,   \"Elfo\" ] The first one will always be used since the path matches first. Predefined values Â¶ If you have a  path operation  that receives a  path parameter , but you want the possible valid  path parameter  values to be predefined, you can use a standard Python  Enum . Create an  Enum  class Â¶ Import  Enum  and create a sub-class that inherits from  str  and from  Enum . By inheriting from  str  the API docs will be able to know that the values must be of type  string  and will be able to render correctly. Then create class attributes with fixed values, which will be the available valid values: Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   \"alexnet\" resnet   =   \"resnet\" lenet   =   \"lenet\" app   =   FastAPI () @app . get ( \"/models/ {model_name} \" ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { \"model_name\" :   model_name ,   \"message\" :   \"Deep Learning FTW!\" } if   model_name . value   ==   \"lenet\" : return   { \"model_name\" :   model_name ,   \"message\" :   \"LeCNN all the images\" } return   { \"model_name\" :   model_name ,   \"message\" :   \"Have some residuals\" } Tip If you are wondering, \"AlexNet\", \"ResNet\", and \"LeNet\" are just names of Machine Learning  models ."
    },
    {
        "id": 28,
        "text": " { \"model_name\" :   model_name ,   \"message\" :   \"Have some residuals\" } Tip If you are wondering, \"AlexNet\", \"ResNet\", and \"LeNet\" are just names of Machine Learning  models . Declare a  path parameter Â¶ Then create a  path parameter  with a type annotation using the enum class you created ( ModelName ): Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   \"alexnet\" resnet   =   \"resnet\" lenet   =   \"lenet\" app   =   FastAPI () @app . get ( \"/models/ {model_name} \" ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { \"model_name\" :   model_name ,   \"message\" :   \"Deep Learning FTW!\" } if   model_name . value   ==   \"lenet\" : return   { \"model_name\" :   model_name ,   \"message\" :   \"LeCNN all the images\" } return   { \"model_name\" :   model_name ,   \"message\" :   \"Have some residuals\" } Check the docs Â¶ Because the available values for the  path parameter  are predefined, the interactive docs can show them nicely: Working with Python  enumerations Â¶ The value of the  path parameter  will be an  enumeration member . Compare  enumeration members Â¶ You can compare it with the  enumeration member  in your created enum  ModelName : Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   \"alexnet\" resnet   =   \"resnet\" lenet   =   \"lenet\" app   =   FastAPI () @app . get ( \"/models/ {model_name} \" ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { \"model_name\" :   model_name ,   \"message\" :   \"Deep Learning FTW!\" } if   model_name . value   ==   \"lenet\" : return   { \"model_name\" :   model_name"
    },
    {
        "id": 29,
        "text": " return   { \"model_name\" :   model_name ,   \"message\" :   \"Deep Learning FTW!\" } if   model_name . value   ==   \"lenet\" : return   { \"model_name\" :   model_name ,   \"message\" :   \"LeCNN all the images\" } return   { \"model_name\" :   model_name ,   \"message\" :   \"Have some residuals\" } Get the  enumeration value Â¶ You can get the actual value (a  str  in this case) using  model_name.value , or in general,  your_enum_member.value : Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   \"alexnet\" resnet   =   \"resnet\" lenet   =   \"lenet\" app   =   FastAPI () @app . get ( \"/models/ {model_name} \" ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { \"model_name\" :   model_name ,   \"message\" :   \"Deep Learning FTW!\" } if   model_name . value   ==   \"lenet\" : return   { \"model_name\" :   model_name ,   \"message\" :   \"LeCNN all the images\" } return   { \"model_name\" :   model_name ,   \"message\" :   \"Have some residuals\" } Tip You could also access the value  \"lenet\"  with  ModelName.lenet.value . Return  enumeration members Â¶ You can return  enum members  from your  path operation , even nested in a JSON body (e.g. a  dict ). They will be converted to their corresponding values (strings in this case) before returning them to the client: Python 3.9+ from   enum   import   Enum from   fastapi   import   FastAPI class   ModelName ( str ,   Enum ): alexnet   =   \"alexnet\" resnet   =   \"resnet\" lenet   =   \"lenet\" app   =   FastAPI () @app . get ( \"/models/ {model_name} \" ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName ."
    },
    {
        "id": 30,
        "text": "   \"lenet\" app   =   FastAPI () @app . get ( \"/models/ {model_name} \" ) async   def   get_model ( model_name :   ModelName ): if   model_name   is   ModelName . alexnet : return   { \"model_name\" :   model_name ,   \"message\" :   \"Deep Learning FTW!\" } if   model_name . value   ==   \"lenet\" : return   { \"model_name\" :   model_name ,   \"message\" :   \"LeCNN all the images\" } return   { \"model_name\" :   model_name ,   \"message\" :   \"Have some residuals\" } In your client you will get a JSON response like: { \"model_name\" :   \"alexnet\" , \"message\" :   \"Deep Learning FTW!\" } Path parameters containing paths Â¶ Let's say you have a  path operation  with a path  /files/{file_path} . But you need  file_path  itself to contain a  path , like  home/johndoe/myfile.txt . So, the URL for that file would be something like:  /files/home/johndoe/myfile.txt . OpenAPI support Â¶ OpenAPI doesn't support a way to declare a  path parameter  to contain a  path  inside, as that could lead to scenarios that are difficult to test and define. Nevertheless, you can still do it in  FastAPI , using one of the internal tools from Starlette. And the docs would still work, although not adding any documentation telling that the parameter should contain a path. Path convertor Â¶ Using an option directly from Starlette you can declare a  path parameter  containing a  path  using a URL like: /files/{file_path:path} In this case, the name of the parameter is  file_path , and the last part,  :path , tells it that the parameter should match any  path . So, you can use it with: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/files/{file_path:path}\" ) async   def   read_file ( file_path :   str ): return   { \"file_path\" :   file_path } Tip You might need the parameter to contain  /home/johndoe/myfile.txt , with a leading slash ( / ). In"
    },
    {
        "id": 31,
        "text": " def   read_file ( file_path :   str ): return   { \"file_path\" :   file_path } Tip You might need the parameter to contain  /home/johndoe/myfile.txt , with a leading slash ( / ). In that case, the URL would be:  /files//home/johndoe/myfile.txt , with a double slash ( // ) between  files  and  home . Recap Â¶ With  FastAPI , by using short, intuitive and standard Python type declarations, you get: Editor support: error checks, autocompletion, etc. Data \" parsing \" Data validation API annotation and automatic documentation And you only have to declare them once. That's probably the main visible advantage of  FastAPI  compared to alternative frameworks (apart from the raw performance). Back to top\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/tutorial/query-params/\n===== PAGE CONTENT =====\nQuery Parameters - FastAPI Skip to content Query Parameters Â¶ When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as \"query\" parameters. Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () fake_items_db   =   [{ \"item_name\" :   \"Foo\" },   { \"item_name\" :   \"Bar\" },   { \"item_name\" :   \"Baz\" }] @app . get ( \"/items/\" ) async   def   read_item ( skip :   int   =   0 ,   limit :   int   =   10 ): return   fake_items_db [ skip   :   skip   +   limit ] The query is the set of key-value pairs that go after the  ?  in a URL, separated by  &  characters. For example, in the URL: http://127.0.0.1:8000/items/?skip=0&limit=10 ...the query parameters are: skip : with a value of  0 limit : with a value of  10 As they are part of the URL, they are \"naturally\" strings. But when you declare them with Python types (in the example above, as  int ), they are converted to that type and validated against it. All the same process that applied for path parameters also applies for query parameters: Editor support (obviously) Data  \"parsing\" Data validation Automatic documentation Defaults Â¶"
    },
    {
        "id": 32,
        "text": " above, as  int ), they are converted to that type and validated against it. All the same process that applied for path parameters also applies for query parameters: Editor support (obviously) Data  \"parsing\" Data validation Automatic documentation Defaults Â¶ As query parameters are not a fixed part of a path, they can be optional and can have default values. In the example above they have default values of  skip=0  and  limit=10 . So, going to the URL: http://127.0.0.1:8000/items/ would be the same as going to: http://127.0.0.1:8000/items/?skip=0&limit=10 But if you go to, for example: http://127.0.0.1:8000/items/?skip=20 The parameter values in your function will be: skip=20 : because you set it in the URL limit=10 : because that was the default value Optional parameters Â¶ The same way, you can declare optional query parameters, by setting their default to  None : Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id :   str ,   q :   str   |   None   =   None ): if   q : return   { \"item_id\" :   item_id ,   \"q\" :   q } return   { \"item_id\" :   item_id } ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id :   str ,   q :   Union [ str ,   None ]   =   None ): if   q : return   { \"item_id\" :   item_id ,   \"q\" :   q } return   { \"item_id\" :   item_id } In this case, the function parameter  q  will be optional, and will be  None  by default. Check Also notice that  FastAPI  is smart enough to notice that the path parameter  item_id  is a path parameter and  q  is not, so, it's a query parameter. Query parameter type"
    },
    {
        "id": 33,
        "text": " be  None  by default. Check Also notice that  FastAPI  is smart enough to notice that the path parameter  item_id  is a path parameter and  q  is not, so, it's a query parameter. Query parameter type conversion Â¶ You can also declare  bool  types, and they will be converted: Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id :   str ,   q :   str   |   None   =   None ,   short :   bool   =   False ): item   =   { \"item_id\" :   item_id } if   q : item . update ({ \"q\" :   q }) if   not   short : item . update ( { \"description\" :   \"This is an amazing item that has a long description\" } ) return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_item ( item_id :   str ,   q :   Union [ str ,   None ]   =   None ,   short :   bool   =   False ): item   =   { \"item_id\" :   item_id } if   q : item . update ({ \"q\" :   q }) if   not   short : item . update ( { \"description\" :   \"This is an amazing item that has a long description\" } ) return   item In this case, if you go to: http://127.0.0.1:8000/items/foo?short=1 or http://127.0.0.1:8000/items/foo?short=True or http://127.0.0.1:8000/items/foo?short=true or http://127.0.0.1:8000/items/foo?short=on or http://127.0.0.1:8000/items/foo?short=yes or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter  short  with a  bool  value of  True . Otherwise as  False . Multiple path and query parameters Â¶ You can"
    },
    {
        "id": 34,
        "text": "?short=yes or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter  short  with a  bool  value of  True . Otherwise as  False . Multiple path and query parameters Â¶ You can declare multiple path parameters and query parameters at the same time,  FastAPI  knows which is which. And you don't have to declare them in any specific order. They will be detected by name: Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/users/ {user_id} /items/ {item_id} \" ) async   def   read_user_item ( user_id :   int ,   item_id :   str ,   q :   str   |   None   =   None ,   short :   bool   =   False ): item   =   { \"item_id\" :   item_id ,   \"owner_id\" :   user_id } if   q : item . update ({ \"q\" :   q }) if   not   short : item . update ( { \"description\" :   \"This is an amazing item that has a long description\" } ) return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/users/ {user_id} /items/ {item_id} \" ) async   def   read_user_item ( user_id :   int ,   item_id :   str ,   q :   Union [ str ,   None ]   =   None ,   short :   bool   =   False ): item   =   { \"item_id\" :   item_id ,   \"owner_id\" :   user_id } if   q : item . update ({ \"q\" :   q }) if   not   short : item . update ( { \"description\" :   \"This is an amazing item that has a long description\" } ) return   item Required query parameters Â¶ When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required. If you don't want to add a specific value but just make it optional, set the default as  None . But when you want to make a query parameter required, you can just not declare any default value"
    },
    {
        "id": 35,
        "text": " parameters), then it is not required. If you don't want to add a specific value but just make it optional, set the default as  None . But when you want to make a query parameter required, you can just not declare any default value: Python 3.9+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_user_item ( item_id :   str ,   needy :   str ): item   =   { \"item_id\" :   item_id ,   \"needy\" :   needy } return   item Here the query parameter  needy  is a required query parameter of type  str . If you open in your browser a URL like: http://127.0.0.1:8000/items/foo-item ...without adding the required parameter  needy , you will see an error like: { \"detail\" :   [ { \"type\" :   \"missing\" , \"loc\" :   [ \"query\" , \"needy\" ], \"msg\" :   \"Field required\" , \"input\" :   null } ] } As  needy  is a required parameter, you would need to set it in the URL: http://127.0.0.1:8000/items/foo-item?needy=sooooneedy ...this would work: { \"item_id\" :   \"foo-item\" , \"needy\" :   \"sooooneedy\" } And of course, you can define some parameters as required, some as having a default value, and some entirely optional: Python 3.10+ from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_user_item ( item_id :   str ,   needy :   str ,   skip :   int   =   0 ,   limit :   int   |   None   =   None ): item   =   { \"item_id\" :   item_id ,   \"needy\" :   needy ,   \"skip\" :   skip ,   \"limit\" :   limit } return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app ."
    },
    {
        "id": 36,
        "text": "   \"limit\" :   limit } return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI app   =   FastAPI () @app . get ( \"/items/ {item_id} \" ) async   def   read_user_item ( item_id :   str ,   needy :   str ,   skip :   int   =   0 ,   limit :   Union [ int ,   None ]   =   None ): item   =   { \"item_id\" :   item_id ,   \"needy\" :   needy ,   \"skip\" :   skip ,   \"limit\" :   limit } return   item In this case, there are 3 query parameters: needy , a required  str . skip , an  int  with a default value of  0 . limit , an optional  int . Tip You could also use  Enum s the same way as with  Path Parameters . Back to top\n\n\n\n===== SOURCE URL =====\nhttps://fastapi.tiangolo.com/tutorial/body/\n===== PAGE CONTENT =====\nRequest Body - FastAPI Skip to content Request Body Â¶ When you need to send data from a client (let's say, a browser) to your API, you send it as a  request body . A  request  body is data sent by the client to your API. A  response  body is the data your API sends to the client. Your API almost always has to send a  response  body. But clients don't necessarily need to send  request bodies  all the time, sometimes they only request a path, maybe with some query parameters, but don't send a body. To declare a  request  body, you use  Pydantic  models with all their power and benefits. Info To send data, you should use one of:  POST  (the more common),  PUT ,  DELETE  or  PATCH . Sending a body with a  GET  request has an undefined behavior in the specifications, nevertheless, it is supported by FastAPI, only for very complex/extreme use cases. As it is discouraged, the interactive docs with Swagger UI won't show the documentation for the body when using  GET , and proxies in the middle might not support it. Import Pydantic's  BaseModel Â¶ First, you need to import  BaseModel  from  pydantic : Python 3."
    },
    {
        "id": 37,
        "text": " won't show the documentation for the body when using  GET , and proxies in the middle might not support it. Import Pydantic's  BaseModel Â¶ First, you need to import  BaseModel  from  pydantic : Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item Create your data model Â¶ Then you declare your data model as a class that inherits from  BaseModel . Use standard Python types for all the attributes: Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item The same as when declaring query parameters, when a model attribute has a default value,"
    },
    {
        "id": 38,
        "text": "   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item The same as when declaring query parameters, when a model attribute has a default value, it is not required. Otherwise, it is required. Use  None  to make it just optional. For example, this model above declares a JSON \" object \" (or Python  dict ) like: { \"name\" :   \"Foo\" , \"description\" :   \"An optional description\" , \"price\" :   45.2 , \"tax\" :   3.5 } ...as  description  and  tax  are optional (with a default value of  None ), this JSON \" object \" would also be valid: { \"name\" :   \"Foo\" , \"price\" :   45.2 } Declare it as a parameter Â¶ To add it to your  path operation , declare it the same way you declared path and query parameters: Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): return   item ...and declare its type as the model you created,  Item . Results Â¶ With just that Python type declaration,  FastAPI  will: Read the body of the request as JSON. Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data. Give you the received data in the parameter  item . As"
    },
    {
        "id": 39,
        "text": ". Convert the corresponding types (if needed). Validate the data. If the data is invalid, it will return a nice and clear error, indicating exactly where and what was the incorrect data. Give you the received data in the parameter  item . As you declared it in the function to be of type  Item , you will also have all the editor support (completion, etc) for all of the attributes and their types. Generate  JSON Schema  definitions for your model, you can also use them anywhere else you like if it makes sense for your project. Those schemas will be part of the generated OpenAPI schema, and used by the automatic documentation  UIs . Automatic docs Â¶ The JSON Schemas of your models will be part of your OpenAPI generated schema, and will be shown in the interactive API docs: And will also be used in the API docs inside each  path operation  that needs them: Editor support Â¶ In your editor, inside your function you will get type hints and completion everywhere (this wouldn't happen if you received a  dict  instead of a Pydantic model): You also get error checks for incorrect type operations: This is not by chance, the whole framework was built around that design. And it was thoroughly tested at the design phase, before any implementation, to ensure it would work with all the editors. There were even some changes to Pydantic itself to support this. The previous screenshots were taken with  Visual Studio Code . But you would get the same editor support with  PyCharm  and most of the other Python editors: Tip If you use  PyCharm  as your editor, you can use the  Pydantic PyCharm Plugin . It improves editor support for Pydantic models, with: auto-completion type checks refactoring searching inspections Use the model Â¶ Inside of the function, you can access all the attributes of the model object directly: Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): item_dict   =   item . model_dump () if   item . tax   is   not   None : price_with_tax"
    },
    {
        "id": 40,
        "text": "   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): item_dict   =   item . model_dump () if   item . tax   is   not   None : price_with_tax   =   item . price   +   item . tax item_dict . update ({ \"price_with_tax\" :   price_with_tax }) return   item_dict ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . post ( \"/items/\" ) async   def   create_item ( item :   Item ): item_dict   =   item . model_dump () if   item . tax   is   not   None : price_with_tax   =   item . price   +   item . tax item_dict . update ({ \"price_with_tax\" :   price_with_tax }) return   item_dict Request body + path parameters Â¶ You can declare path parameters and request body at the same time. FastAPI  will recognize that the function parameters that match path parameters should be  taken from the path , and that function parameters that are declared to be Pydantic models should be  taken from the request body . Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . put ( \"/items/ {item_id} \" ) async   def   update_item ( item_id :   int ,   item :   Item ): return   { \"item_id\" :   item_id ,   ** item . model_dump ()} ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :  "
    },
    {
        "id": 41,
        "text": " Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . put ( \"/items/ {item_id} \" ) async   def   update_item ( item_id :   int ,   item :   Item ): return   { \"item_id\" :   item_id ,   ** item . model_dump ()} Request body + path + query parameters Â¶ You can also declare  body ,  path  and  query  parameters, all at the same time. FastAPI  will recognize each of them and take the data from the correct place. Python 3.10+ from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   str   |   None   =   None price :   float tax :   float   |   None   =   None app   =   FastAPI () @app . put ( \"/items/ {item_id} \" ) async   def   update_item ( item_id :   int ,   item :   Item ,   q :   str   |   None   =   None ): result   =   { \"item_id\" :   item_id ,   ** item . model_dump ()} if   q : result . update ({ \"q\" :   q }) return   result ğŸ¤“ Other versions and variants Python 3.9+ from   typing   import   Union from   fastapi   import   FastAPI from   pydantic   import   BaseModel class   Item ( BaseModel ): name :   str description :   Union [ str ,   None ]   =   None price :   float tax :   Union [ float ,   None ]   =   None app   =   FastAPI () @app . put ( \"/items/ {item_id} \" ) async   def   update_item ( item_id :   int ,   item :   Item ,   q :   Union [ str ,   None ]   =   None ): result   =   { \"item_id\" :   item_id ,   ** item . model_dump ()} if   q : result . update ({ \"q\" :   q }) return   result"
    },
    {
        "id": 42,
        "text": " str ,   None ]   =   None ): result   =   { \"item_id\" :   item_id ,   ** item . model_dump ()} if   q : result . update ({ \"q\" :   q }) return   result The function parameters will be recognized as follows: If the parameter is also declared in the  path , it will be used as a path parameter. If the parameter is of a  singular type  (like  int ,  float ,  str ,  bool , etc) it will be interpreted as a  query  parameter. If the parameter is declared to be of the type of a  Pydantic model , it will be interpreted as a request  body . Note FastAPI will know that the value of  q  is not required because of the default value  = None . The  str | None  (Python 3.10+) or  Union  in  Union[str, None]  (Python 3.9+) is not used by FastAPI to determine that the value is not required, it will know it's not required because it has a default value of  = None . But adding the type annotations will allow your editor to give you better support and detect errors. Without Pydantic Â¶ If you don't want to use Pydantic models, you can also use  Body  parameters. See the docs for  Body - Multiple Parameters: Singular values in body . Back to top\n"
    }
]